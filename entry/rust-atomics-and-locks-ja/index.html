<!doctype html><html lang=ja><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=https://blog.ymgyt.io/favicon.ico rel=icon sizes=any><link href=https://blog.ymgyt.io/icon.svg rel=icon type=image/svg+xml><link href=https://blog.ymgyt.io/apple-touch-icon.png rel=apple-touch-icon><link href=https://blog.ymgyt.io/manifest.webmanifest rel=manifest><link href=https://blog.ymgyt.io/style.css rel=stylesheet><link href=https://blog.ymgyt.io/atom.xml rel=alternate title=Atom type=application/atom+xml><script src="https://www.googletagmanager.com/gtag/js?id=G-GTB0KMLN90" async></script><script>window.dataLayer = window.dataLayer || [];
	function gtag() {dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-GTB0KMLN90');</script><title>📕 詳解 Rustアトミック操作とロックを読んだ感想 | Happy developing</title><meta content=std::sync::atomic::{Ordering,fence}がわかる本 name=description><meta content=summary name=twitter:card><meta content="@YAmaguchixt " name=twitter:site><meta content="📕 詳解 Rustアトミック操作とロックを読んだ感想" name=twitter:title><meta content=std::sync::atomic::{Ordering,fence}がわかる本 name=twitter:description><meta content=https://blog.ymgyt.io/images/emoji/closed_book.png name=twitter:image><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><body><div class=world><div class=content-container><header class=blog-header-container><div class=blog-logo><a href=https://blog.ymgyt.io>Happy developing</a></div><div class=blog-nav><nav><ul><li><a href=https://blog.ymgyt.io/entry/>Entries</a><li><a href=https://blog.ymgyt.io/tags/>Tags</a><li><a href=https://blog.ymgyt.io/about/>About</a><li><a href=https://github.com/ymgyt> <img alt=Github class=icon src=https://blog.ymgyt.io/images/icon/github.svg> </a><li><a href="https://twitter.com/YAmaguchixt "> <img alt=Twitter class=icon src=https://blog.ymgyt.io/images/icon/twitter.svg> </a></ul></nav></div></header><main class=blog-main><article><header class=entry-header><h1 class=entry-title>📕 詳解 Rustアトミック操作とロックを読んだ感想</h1><div class=entry-meta><p class=entry-meta-item>🗓 2023-11-28<p class=entry-meta-item>🏷 <span class=tag><a href=https://blog.ymgyt.io/tags/rust/>rust</a></span> <span class=tag><a href=https://blog.ymgyt.io/tags/book/>book</a></span></div></header><aside class=entry-toc><nav><ul class=entry-toc-toplevel-list><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#du-ndaben>読んだ本</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#rust-atomics-and-lockswodu-ndekara>Rust Atomics and Locksを読んでから</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#matome>まとめ</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#1zhang-rustping-xing-xing-noji-ben>1章 Rust平行性の基本</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#2zhang-atomitukucao-zuo>2章 アトミック操作</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#3zhang-memoriodaringu>3章 メモリオーダリング</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#4zhang-supinrotukunoshi-zhuang>4章 スピンロックの実装</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#5zhang-tiyannerunoshi-zhuang>5章 チャンネルの実装</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#6zhang-arcnoshi-zhuang>6章 Arcの実装</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#7zhang-purosetusawoli-jie-suru>7章 プロセッサを理解する</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#read-modify-write>Read modify write</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#compare-and-exchange>compare and exchange</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#ordering>Ordering</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#fence>fence</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#8zhang-ospurimiteibu>8章 OSプリミティブ</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#9zhang-rotukunoshi-zhuang>9章ロックの実装</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#10zhang-aideiatoinsupiresiyon>10章 アイディアとインスピレーション</a><li><a href=https://blog.ymgyt.io/entry/rust-atomics-and-locks-ja/#zui-hou-ni>最後に</a></ul></nav></aside><div class=entry-content><h2 id=du-ndaben><a aria-label="Anchor link for: du-ndaben" class=zola-anchor href=#du-ndaben>読んだ本</a></h2><figure><div class=fig-images-row><img , alt src=images/raal-ja-book.jpeg></div></figure><p><a href=https://www.oreilly.co.jp/books/9784814400515/ rel=external>詳解 Rustアトミック操作とロック</a><p>著者: <a href=https://m-ou.se/ rel=external>Mara Bos</a><br> 訳者: <a href=https://twitter.com/hidemotoNakada rel=external>中田秀基</a><p>あの、<a href=https://marabos.nl/atomics/ rel=external>Rust Atomics and Locks</a>の日本語翻訳がついに販売されました。<br> Rust Atomics and Locksについては去年、<a href=https://blog.ymgyt.io/entry/rust_atomics_and_locks/ rel=external>読んだ感想</a>を書きました。<p>本記事ではあらためて日本語訳を読んだ感想を書きます。<h2 id=rust-atomics-and-lockswodu-ndekara><a aria-label="Anchor link for: rust-atomics-and-lockswodu-ndekara" class=zola-anchor href=#rust-atomics-and-lockswodu-ndekara>Rust Atomics and Locksを読んでから</a></h2><p>Rust Atomics and Locksを読む前は、CPUはメモリから命令をfetchした後、実行して結果をregisterないしメモリに書き戻すというのが自分のメンタルモデルでした。<br> CPUとメモリの間にはcacheがあるものの、performanceを考慮しなければプログラマーには透過的で意識しなくてよいものと思っていました。<br> しかし、このメンタルモデルは誤っていることがわかりました。 実際はCPUコアごとに独立したcacheが存在している。CPUコアごとのcacheの整合性(cache coherence)を保つためにCPUコアはなんらかのprotocolでcacheの問い合わせや無効を行っている。cacheの更新自体もqueueでうけられて非同期。したがって、CPUコアAによる変数A,Bへの書き込みがなされても、CPUコアBには変数Bの変更しか観測されないという場合がありえる。<br> と考えるようになりました。そのため、atomicについて知るにはもうすこしCPUのことがわかりたいと思うようになり、以下の本を読みました。<ul><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/ rel=external>もっとCPUの気持ちがしりたいですか?</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/ rel=external>プログラマーのためのCPU入門</a><li><a href=https://gihyo.jp/book/2011/978-4-7741-4521-1 rel=external>プロセッサを支える技術</a><li><a href=https://riscv.or.jp/risc-v-publication/ rel=external>RISC-V原典 オープンアーキテクチャのススメ</a></ul><p>これらの本を読んで、プログラムでは変数A,Bと変更してもそれがthread間でどう見えるかは<ul><li>Compilerによるreorder<li>CPUのout of order実行<li>CPUコアのcache coherence</ul><p>の影響をうけると考えるようになりました。<br> つまり、ソースからは判断できない。<br> そこでプログラマーが、変数AとBが、例えば、BがReadyを表し、BのReadyを確認してはじめてAを読んでよいというような変数間の依存関係を表現できるようにRustが、Platformに依存しない最大公約数的な保証が行える範囲でAPIを公開してくれている。それがstd::sync::atomicに現れている。という理解に至りました。 あっているかわかりませんが、このような仮説をもって本書を読みました。<h2 id=matome><a aria-label="Anchor link for: matome" class=zola-anchor href=#matome>まとめ</a></h2><p>自分のように<a href=https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html rel=external><code>std::sync::atomic::Ordering</code></a>や<a href=https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU32.html#method.compare_exchange rel=external><code>compare_exchange()</code></a>がよくわからないと思っている方に是非読んでみてほしいと思いました。<br> <code>AtomicI32::store(Ordering::Release)</code>と<code>AtomicI32::load(Ordering::Acquire)</code>にどのような意図が込められているかわかるようになります。<p>また、具体例が豊富で、atomic関連だけでなくrust全般の理解も進むと思います。<h2 id=1zhang-rustping-xing-xing-noji-ben><a aria-label="Anchor link for: 1zhang-rustping-xing-xing-noji-ben" class=zola-anchor href=#1zhang-rustping-xing-xing-noji-ben>1章 Rust平行性の基本</a></h2><p>本書で登場する型や各種概念について説明されます。<br> 具体的には<ul><li><code>std::thread</code>の<code>spawn()</code>や<code>scope()</code>の使い方<li><code>Rc</code>、<code>Arc</code>やInterior mutability(<code>RefCell</code>,<code>Mutex</code>,...)<li>thread safety(<code>Send</code>,<code>Sync</code>)<li><code>std::sync::{Mutex, Condvar}</code>の基本<li><code>thread::park()</code>や<code>Thread::unpark()</code>の使い方</ul><p><a href=https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html#accurate-mental-model-for-rusts-reference-types rel=external>dtolnay先生のAccurate mental model for Rust's reference types</a>でも述べられていますが、<code>&T</code>を不変ではなく共有参照、<code>&mut T</code>を可変でなく排他参照と考えるのがよいとされています。<code>Mutex</code>や<code>Atomic</code>変数がでてくると、<code>&T</code>でも内部のデータが変わるからです。<p><code>Cell</code>が<code>Atomic</code>のsingle thread版、<code>RefCell</code>が<code>RwLock</code>のsingle thread版という説明はわかりやすいと思いました。<p>条件変数の<code>Condvar</code>はいまいち使いどころがわかっていなかったのですが、threadのparkとの対比の説明がわかりやすかったです。 <code>Condvar::wait()</code>の引数に<code>Mutex</code>の<code>MutexGuard</code>が必要なのは、呼び出し側でunlockしてからwaitすると、その間の通知を逃してしまうからとわかり疑問がひとつ解消されてうれしかったです。<h2 id=2zhang-atomitukucao-zuo><a aria-label="Anchor link for: 2zhang-atomitukucao-zuo" class=zola-anchor href=#2zhang-atomitukucao-zuo>2章 アトミック操作</a></h2><p>Atomic変数(<code>AtomicI32</code>等)の使い方が説明されます。<br> 具体例が豊富で親切です。 英語版でも書きましたが、まず<code>Ordering::Relaxed</code>だけを説明してくれる構成がとてもわかりやすいと思います。<p>具体例の1つに、globalでuniqueなIDを発行する処理が取り上げられるのですが、値をincrementするだけの処理でもmulti threadになると如何に複雑になるのかがわかります。<h2 id=3zhang-memoriodaringu><a aria-label="Anchor link for: 3zhang-memoriodaringu" class=zola-anchor href=#3zhang-memoriodaringu>3章 メモリオーダリング</a></h2><p>もし1章だけ読むとしたら、3章になると思います。 なぜメモリオーダリング(<code>std::sync::atomic::Ordering</code>)が必要なのか。メモリオーダリングによってなにが保証されるのかがわかります。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>use</span><span> std</span><span style=color:#81a1c1>::</span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span>    sync</span><span style=color:#81a1c1>::</span><span>atomic</span><span style=color:#81a1c1>::</span><span style=color:#eceff4>{</span><span style=color:#8fbcbb>AtomicBool</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> AtomicU32</span><span style=color:#eceff4>,</span><span> Ordering</span><span style=color:#81a1c1>::*</span><span style=color:#eceff4>},</span></span>
<span class=giallo-l><span>    thread</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>    time</span><span style=color:#81a1c1>::</span><span style=color:#8fbcbb>Duration</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>};</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>static</span><span> DATA</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> AtomicU32</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> AtomicU32</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>new</span><span style=color:#eceff4>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#81a1c1>static</span><span> READY</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> AtomicBool</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> AtomicBool</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>new</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>false</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> main</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span>    thread</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>spawn</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>||</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        DATA</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>store</span><span style=color:#eceff4>(</span><span style=color:#b48ead>123</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> Relaxed</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span>        READY</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>store</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>true</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> Release</span><span style=color:#eceff4>);</span><span style=color:#616e88> // 👈</span></span>
<span class=giallo-l><span style=color:#eceff4>    });</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    while !</span><span>READY</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>load</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Acquire</span><span style=color:#eceff4>) {</span><span style=color:#616e88> // 👈</span></span>
<span class=giallo-l><span>        thread</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>sleep</span><span style=color:#eceff4>(</span><span>Duration</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>from_millis</span><span style=color:#eceff4>(</span><span style=color:#b48ead>100</span><span style=color:#eceff4>));</span></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>        println!</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>waiting...</span><span style=color:#eceff4>");</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>    assert_eq!</span><span style=color:#eceff4>(</span><span>DATA</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>load</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Relaxed</span><span style=color:#eceff4>),</span><span style=color:#b48ead> 123</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>上記のcodeで、なぜ<code>Relase</code>と<code>Acquire</code>を指定すべきかがわかります。<p>自分は英語版でのhappens-before relationshipsの説明を理解できているか確かめたくて本書を読みました。<br> また、<code>std::sync::atomic::fence</code>関数の説明もあります。fenceとhappens-before relationshipsの関係も解説されており非常にありがたいです。<h2 id=4zhang-supinrotukunoshi-zhuang><a aria-label="Anchor link for: 4zhang-supinrotukunoshi-zhuang" class=zola-anchor href=#4zhang-supinrotukunoshi-zhuang>4章 スピンロックの実装</a></h2><p><code>AtomicBool</code>を利用して、lock機能を提供する<code>SpinLock</code>を実装していきます。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> SpinLock</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span>    value</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> UnsafeCell</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>>,</span></span>
<span class=giallo-l><span>    locked</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> AtomicBool</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>// ...</span></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> main</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> x</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> SpinLock</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>new</span><span style=color:#eceff4>(</span><span>Vec</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>new</span><span style=color:#eceff4>());</span></span>
<span class=giallo-l><span>    thread</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>scope</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>|</span><span>s</span><span style=color:#81a1c1>|</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        s</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>spawn</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>||</span><span> x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>lock</span><span style=color:#eceff4>()</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>push</span><span style=color:#eceff4>(</span><span style=color:#b48ead>1</span><span style=color:#eceff4>));</span></span>
<span class=giallo-l><span>        s</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>spawn</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>||</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>            let mut</span><span> g</span><span style=color:#81a1c1> =</span><span> x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>lock</span><span style=color:#eceff4>();</span></span>
<span class=giallo-l><span>            g</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>push</span><span style=color:#eceff4>(</span><span style=color:#b48ead>2</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span>            g</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>push</span><span style=color:#eceff4>(</span><span style=color:#b48ead>2</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>        });</span></span>
<span class=giallo-l><span style=color:#eceff4>    });</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> g</span><span style=color:#81a1c1> =</span><span> x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>lock</span><span style=color:#eceff4>();</span></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>    assert!</span><span style=color:#eceff4>(</span><span>g</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>as_slice</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> ==</span><span style=color:#eceff4> [</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 2</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 2</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> ||</span><span> g</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>as_slice</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> ==</span><span style=color:#eceff4> [</span><span style=color:#b48ead>2</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 2</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 1</span><span style=color:#eceff4>]);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>lockを表現するGuard型がどうしてあらわれるのかがわかり、rustのapi全般の理解が進みました。<h2 id=5zhang-tiyannerunoshi-zhuang><a aria-label="Anchor link for: 5zhang-tiyannerunoshi-zhuang" class=zola-anchor href=#5zhang-tiyannerunoshi-zhuang>5章 チャンネルの実装</a></h2><p><code>UnsafeCell</code>と<code>MaybeUninit</code>を利用して、一度だけ値をsendできる、<code>tokio::sync::oneshot</code>のようなchannelを実装していきます。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> Channel</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span>    message</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> UnsafeCell</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>MaybeUninit</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>>>,</span></span>
<span class=giallo-l><span>    state</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> AtomicU8</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>// ...</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> main</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span style=color:#eceff4> (</span><span>sender</span><span style=color:#eceff4>,</span><span> receiver</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> Channel</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>split</span><span style=color:#eceff4>();</span></span>
<span class=giallo-l><span>    thread</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>scope</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>move |</span><span>s</span><span style=color:#81a1c1>|</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        s</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>spawn</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>move ||</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>            sender</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>send</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>Hello</span><span style=color:#eceff4>");</span></span>
<span class=giallo-l><span style=color:#eceff4>        });</span></span>
<span class=giallo-l><span style=color:#eceff4>    });</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> m</span><span style=color:#81a1c1> =</span><span> receiver</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>receive</span><span style=color:#eceff4>();</span></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>    println!</span><span style=color:#eceff4>("</span><span style=color:#ebcb8b>{</span><span style=color:#a3be8c>m</span><span style=color:#ebcb8b>}</span><span style=color:#eceff4>");</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p><code>Arc</code>を利用する例や、allocationを避けるパターン等がのっています。<h2 id=6zhang-arcnoshi-zhuang><a aria-label="Anchor link for: 6zhang-arcnoshi-zhuang" class=zola-anchor href=#6zhang-arcnoshi-zhuang>6章 Arcの実装</a></h2><p>本章では<code>Arc</code>を実装します。<br> <code>Arc</code>の実態は以下のように定義されたheap上に確保された<code>ArcData</code>ということがわかります。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> ArcData</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span>    ref_count</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> AtomicUsize</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>    data</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> T</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> Arc</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span>    ptr</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> NonNull</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>ArcData</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>>>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p><code>Arc</code>をdropする際に、それが最後の<code>Arc</code>の場合に限って、orderingを変えたい際に<code>fence</code>が利用できる例の解説があります。 また、循環参照を表現できるように<code>Weak</code>も実装します。<br> <code>Weak</code>もheap上の<code>ArcData</code>を参照しているはずなのに、<code>Arc</code>がなくなれば<code>Arc&lt;T></code>の<code>T</code>はdropされる一見不思議なapiがどのように実装されているかわかります。<p>愚直に実装しようと思うと、<code>Arc</code>と<code>Weak</code>の数を別々のatomic変数で管理したくなります。しかしながら、２つのatomic変数が同時に0であることは確かめられないので、いかにWeakの数を管理するかが課題となります。最終的な実装はstdの実装とほぼ同じになるそうです。<h2 id=7zhang-purosetusawoli-jie-suru><a aria-label="Anchor link for: 7zhang-purosetusawoli-jie-suru" class=zola-anchor href=#7zhang-purosetusawoli-jie-suru>7章 プロセッサを理解する</a></h2><p>本章ではこれまで扱ってきたatomic操作がどのような機械語にcompileされるかを扱います。<br> 本書ではx86-64とARM64をtargetとして解説があります。<br> 自分は<a href=https://godbolt.org/ rel=external>Compiler Explorer</a>で、Target architectureとして<code>riscv64gc-unknown-linux-gnu</code>を利用しました。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> a</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &mut</span><span style=color:#8fbcbb> i32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    *</span><span>x</span><span style=color:#81a1c1> =</span><span style=color:#b48ead> 0</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>まず上記のように引数のpointerに0を代入する関数は以下のようにcompileされました。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>example::a:</span></span>
<span class=giallo-l><span>        sw      zero, 0(a0)</span></span>
<span class=giallo-l><span>        ret  </span></span></code></pre><p><code>sw rs2 offset(rs1)</code>はstore word命令で、rs1+offsetのメモリアドレスにrs2の内容を書き込む命令です。<br> <code>a0</code> registerは関数の第一引数が格納されるregisterです。<br> <code>zero</code>は常に0として扱われる特別なregisterです。<br> なので、<code>sw zero, 0(a0)</code>は第一引数のaddressに0を書き込むと解釈できます。<br> <code>ret</code>は疑似命令でassembly上では登場するが実際には違う機械語に変換されます。<br> <code>ret</code>の場合は<code>jalr zero, 0(ra)</code>になります。<code>jalr</code>はjump and link register命令で、raのaddressにjump(pcを書き換える)します。現在のpc + 4のaddressをregisterに書き込みますが、関数から戻る場合は不要なのでzeroに書き込んでいます。raには関数呼び出し時に戻り先のaddressが格納されています。<p>続いて、atomic変数にRelaxedで書き込む関数を見てみます。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> a</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>store</span><span style=color:#eceff4>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb>Relaxed</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>example::a:</span></span>
<span class=giallo-l><span>        sw      zero, 0(a0)</span></span>
<span class=giallo-l><span>        ret</span></span></code></pre><p>atomicでない<code>&mut</code>と同じ命令となりました。<br> <code>&mut</code>と<code>&AtomicI32</code>ではcompilerによる扱いは変わる場合があるそうですが、関数単位では同じ機械語となりました。<p>読み込み(load)処理も同様でした。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> a</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>i32</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> i32</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    *</span><span>x</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> b</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> i32</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>load</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Relaxed</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>example::a:</span></span>
<span class=giallo-l><span>        lw      a0, 0(a0)</span></span>
<span class=giallo-l><span>        ret</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>example::b:</span></span>
<span class=giallo-l><span>        lw      a0, 0(a0)</span></span>
<span class=giallo-l><span>        ret</span></span></code></pre><p><code>lw</code>はload word命令で、a0から第一引数のaddressを取得して、その値をa0に書き込んでいます。a0は戻り値を返すためのregisterです。<h3 id=read-modify-write><a aria-label="Anchor link for: read-modify-write" class=zola-anchor href=#read-modify-write>Read modify write</a></h3><p>次はatomicでないread-modify-write処理です。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> a</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &mut</span><span style=color:#8fbcbb> i32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    *</span><span>x</span><span style=color:#81a1c1> +=</span><span style=color:#b48ead> 10</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>こちらはread,modify,writeと3つの命令になりました。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>example::a:</span></span>
<span class=giallo-l><span>        lw      a1, 0(a0)</span></span>
<span class=giallo-l><span>        addiw   a1, a1, 10</span></span>
<span class=giallo-l><span>        sw      a1, 0(a0)</span></span>
<span class=giallo-l><span>        ret  </span></span></code></pre><p><code>addiw</code>はadd word immediate命令で、a1に10を足してa1に書き込みます。<br> Atomic版をみてみると<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> a</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>fetch_add</span><span style=color:#eceff4>(</span><span style=color:#b48ead>10</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> Relaxed</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>example::a:</span></span>
<span class=giallo-l><span>        li      a1, 10</span></span>
<span class=giallo-l><span>        amoadd.w        a0, a1, (a0)</span></span>
<span class=giallo-l><span>        ret</span></span></code></pre><p><code>li</code>はload immediateという疑似命令で、10をa1に書き込みます。<br> <code>amoadd.w</code>はatomic memory operation add word命令で、a0のaddressの値とa1を加算して結果をa0とa0のaddressに書き込みます。<br> ということで、riscvだとfetch_addは1命令になることがわかりました。<h3 id=compare-and-exchange><a aria-label="Anchor link for: compare-and-exchange" class=zola-anchor href=#compare-and-exchange>compare and exchange</a></h3><p>compare_exchangeが成功するまでloopする処理をみてみます。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> a</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> i32</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let mut</span><span> current</span><span style=color:#81a1c1> =</span><span> x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>load</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Relaxed</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#81a1c1>    loop</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>        let</span><span> new</span><span style=color:#81a1c1> =</span><span> current</span><span style=color:#81a1c1> +</span><span style=color:#b48ead> 10</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>        match</span><span> x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>compare_exchange</span><span style=color:#eceff4>(</span><span>current</span><span style=color:#eceff4>,</span><span>new</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb>Relaxed</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb>Relaxed</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#8fbcbb>            Ok</span><span style=color:#eceff4>(</span><span>v</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> => return</span><span> v</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#8fbcbb>            Err</span><span style=color:#eceff4>(</span><span>v</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> =></span><span> current</span><span style=color:#81a1c1> =</span><span> v</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>        }</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>example::a:</span></span>
<span class=giallo-l><span>        lw      a1, 0(a0)</span></span>
<span class=giallo-l><span>.LBB0_1:</span></span>
<span class=giallo-l><span>        addiw   a2, a1, 10</span></span>
<span class=giallo-l><span>        sext.w  a3, a1</span></span>
<span class=giallo-l><span>.LBB0_3:</span></span>
<span class=giallo-l><span>        lr.w    a1, (a0)</span></span>
<span class=giallo-l><span>        bne     a1, a3, .LBB0_1</span></span>
<span class=giallo-l><span>        sc.w    a4, a2, (a0)</span></span>
<span class=giallo-l><span>        bnez    a4, .LBB0_3</span></span>
<span class=giallo-l><span>        mv      a0, a1</span></span>
<span class=giallo-l><span>        ret  </span></span></code></pre><p><code>sext.w</code>は<code>addiw a3, a1, 0</code>の疑似命令です。<br> <code>lr.w</code>はload reserved命令で、a0からa1に読み込んだ際に当該addressに印をつけ、他のthreadが同一addressにアクセスしたかどうかを記録します。<br> <code>sc.w</code>はstore conditional命令で、a0 addressにa2を値を書き込み、lr.w以降他のthreadからアクセスされていなければ、a4に0を書き込みます。<br> <code>bne</code>はbranch if not equal命令で、a1とa3が異なる場合、labelにjumpします。<code>bnez</code>は<code>bne a4 zero</code>の疑似命令です。<p>ということで、compare exchangeのloopはload reservedとstore conditionalを用いたloopに対応することがわかりました。<br> また、<code>x.compare_exchange()</code>を<code>x.compare_exchange_weak()</code>に変えても命令は変化しませんでした。<h3 id=ordering><a aria-label="Anchor link for: ordering" class=zola-anchor href=#ordering>Ordering</a></h3><p>まず、store,load,read-modify-writeに<code>SeqCst</code>を指定した場合について。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> a</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>store</span><span style=color:#eceff4>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> SeqCst</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> b</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> i32</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>load</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>SeqCst</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> c</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>fetch_add</span><span style=color:#eceff4>(</span><span style=color:#b48ead>10</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> SeqCst</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>example::a:</span></span>
<span class=giallo-l><span>        fence   rw, w</span></span>
<span class=giallo-l><span>        sw      zero, 0(a0)</span></span>
<span class=giallo-l><span>        ret</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>example::b:</span></span>
<span class=giallo-l><span>        fence   rw, rw</span></span>
<span class=giallo-l><span>        lw      a0, 0(a0)</span></span>
<span class=giallo-l><span>        fence   r, rw</span></span>
<span class=giallo-l><span>        ret  </span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>example::c:</span></span>
<span class=giallo-l><span>        li      a1, 10</span></span>
<span class=giallo-l><span>        amoadd.w.aqrl   a0, a1, (a0)</span></span>
<span class=giallo-l><span>        ret</span></span></code></pre><p>上記のように<code>fence</code>命令が使用された。<br> RISC-V Spec 2.7 Memory Ordering Instructionsではfence命令について<blockquote><p>Informally, no other RISC-V hart or external device can observe any operation in the successor set following a FENCE before any operation in the predecessor set preceding the FENCE.</blockquote><p>と説明されていた。<code>fence pred succ</code>なので自分の理解では<code>fence rw, w</code>は<br> このfence命令より以前のメモリのread/write命令はfence命令よりあとのメモリwrite命令より先に他のthreadに観測されなければならないとなる。<p>まとめると、<code>SeqCst</code> orderingを利用するとその前後で他のthreadに対してこれまでの操作が後続する操作よりも前に観測されることとなるようだった。<p>また<code>amoadd.w.aqrl</code>は、<code>amoadd</code>命令のacとrl bitをそれぞれ1にしていることがわかる。<p>続いて、Release/Acquire orderingについて。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> a</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>store</span><span style=color:#eceff4>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> Release</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> b</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> i32</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>load</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Acquire</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> c</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicI32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span>    x</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>fetch_add</span><span style=color:#eceff4>(</span><span style=color:#b48ead>10</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> AcqRel</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>example::a:</span></span>
<span class=giallo-l><span>        fence   rw, w</span></span>
<span class=giallo-l><span>        sw      zero, 0(a0)</span></span>
<span class=giallo-l><span>        ret</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>example::b:</span></span>
<span class=giallo-l><span>        lw      a0, 0(a0)</span></span>
<span class=giallo-l><span>        fence   r, rw</span></span>
<span class=giallo-l><span>        ret</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>example::c:</span></span>
<span class=giallo-l><span>        li      a1, 10</span></span>
<span class=giallo-l><span>        amoadd.w.aqrl   a0, a1, (a0)</span></span>
<span class=giallo-l><span>        ret</span></span></code></pre><p>これは3章のfench命令の説明の通り、release storeはfence + store、acquire loadはload + fenceに対応する命令が生成されることがわかった。<br> またriscvにおいては<code>SeqCst</code>と<code>AcqRel</code> orderingで同じ<code>amoadd.w.aqrl</code>命令が生成されることが確かめられた。<h3 id=fence><a aria-label="Anchor link for: fence" class=zola-anchor href=#fence>fence</a></h3><p>最後にfence命令について。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> a</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#88c0d0>    fence</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Acquire</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> b</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#88c0d0>    fence</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Release</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> c</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#88c0d0>    fence</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>AcqRel</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> d</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#88c0d0>    fence</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>SeqCst</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>example::a:</span></span>
<span class=giallo-l><span>        fence   r, rw</span></span>
<span class=giallo-l><span>        ret</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>example::b:</span></span>
<span class=giallo-l><span>        fence   rw, w</span></span>
<span class=giallo-l><span>        ret</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>example::c:</span></span>
<span class=giallo-l><span>        fence.tso</span></span>
<span class=giallo-l><span>        ret</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>example::d:</span></span>
<span class=giallo-l><span>        fence   rw, rw</span></span>
<span class=giallo-l><span>        ret</span></span></code></pre><p>という結果になりました。<br> <code>fence.tso</code>はさきほどの仕様 2.7で<blockquote><p>The optional FENCE.TSO instruction is encoded as a FENCE instruction with fm=1000, predeces- sor=RW, and successor=RW. FENCE.TSO orders all load operations in its predecessor set before all memory operations in its successor set, and all store operations in its predecessor set before all store operations in its successor set. This leaves non-AMO store operations in the FENCE.TSO’s predecessor set unordered with non-AMO loads in its successor set.</blockquote><p>と説明されていました。fence命令のfmがどういったものが理解できておらずいまいちよくわかっていません。<br> fence命令がriscvにおけるatomic理解の鍵となりそうなので、今後調べていきたいです。<p>また本章ではcacheの一貫性(coherence)やcache line、x86-64とARM64のorderingの違い等が説明されます。<h2 id=8zhang-ospurimiteibu><a aria-label="Anchor link for: 8zhang-ospurimiteibu" class=zola-anchor href=#8zhang-ospurimiteibu>8章 OSプリミティブ</a></h2><p>4章のスピンロックを利用すれば、kernelの機能を利用せずにロックを実装することができる。しかしスケジューリングを通じてthreadを動かしたり止めたりするのはkernelなので、kernelにthreadが何かをまっていることを伝えたほうがリソースを有効活用できる。<p>本章では各Platform(Linux,macOS,Windows,...)でRustがどのようにロック関連のsystem callを行うかの概要が説明される。<br> 特にLinuxのsystem callの1つである、futex(fast user-space mutex)が解説されます。<br> Futexでは、atomic変数を起点にして、waitやwakeを実装することができます。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>use</span><span> std</span><span style=color:#81a1c1>::</span><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span>    sync</span><span style=color:#81a1c1>::</span><span>atomic</span><span style=color:#81a1c1>::</span><span style=color:#eceff4>{</span><span style=color:#8fbcbb>AtomicU32</span><span style=color:#eceff4>,</span><span> Ordering</span><span style=color:#81a1c1>::*</span><span style=color:#eceff4>},</span></span>
<span class=giallo-l><span>    thread</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>    time</span><span style=color:#81a1c1>::</span><span style=color:#8fbcbb>Duration</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>};</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#5e81ac>#[cfg(not(target_os = "</span><span style=color:#a3be8c>linux</span><span style=color:#5e81ac>"))]</span></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>compile_error!</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>Linux only.</span><span style=color:#eceff4>");</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> wait</span><span style=color:#eceff4>(</span><span>a</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicU32</span><span style=color:#eceff4>,</span><span> expected</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> u32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    unsafe</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        libc</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>syscall</span><span style=color:#eceff4>(</span></span>
<span class=giallo-l><span>            libc</span><span style=color:#81a1c1>::</span><span style=color:#8fbcbb>SYS_futex</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>            a</span><span style=color:#81a1c1> as *const</span><span style=color:#8fbcbb> AtomicU32</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>            libc</span><span style=color:#81a1c1>::</span><span>FUTEX_WAIT</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>            expected</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>            std</span><span style=color:#81a1c1>::</span><span>ptr</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>null</span><span style=color:#81a1c1>::</span><span style=color:#eceff4>&lt;</span><span>libc</span><span style=color:#81a1c1>::</span><span>timespec</span><span style=color:#eceff4>>(),</span></span>
<span class=giallo-l><span style=color:#eceff4>        );</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> wake_one</span><span style=color:#eceff4>(</span><span>a</span><span style=color:#81a1c1>: &</span><span style=color:#8fbcbb>AtomicU32</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    unsafe</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        libc</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>syscall</span><span style=color:#eceff4>(</span><span>libc</span><span style=color:#81a1c1>::</span><span style=color:#8fbcbb>SYS_futex</span><span style=color:#eceff4>,</span><span> a</span><span style=color:#81a1c1> as *const</span><span style=color:#8fbcbb> AtomicU32</span><span style=color:#eceff4>,</span><span> libc</span><span style=color:#81a1c1>::</span><span>FUTEX_WAKE</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 1</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> main</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> a</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> AtomicU32</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>new</span><span style=color:#eceff4>(</span><span style=color:#b48ead>0</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    thread</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>scope</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>|</span><span>s</span><span style=color:#81a1c1>|</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        s</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>spawn</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>||</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>            thread</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>sleep</span><span style=color:#eceff4>(</span><span>Duration</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>from_secs</span><span style=color:#eceff4>(</span><span style=color:#b48ead>3</span><span style=color:#eceff4>));</span></span>
<span class=giallo-l><span>            a</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>store</span><span style=color:#eceff4>(</span><span style=color:#b48ead>1</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> Relaxed</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#88c0d0>            wake_one</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&</span><span>a</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>        });</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>        println!</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>Waiting...</span><span style=color:#eceff4>");</span></span>
<span class=giallo-l><span style=color:#81a1c1>        while</span><span> a</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>load</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Relaxed</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> ==</span><span style=color:#b48ead> 0</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#88c0d0>            wait</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&</span><span>a</span><span style=color:#eceff4>,</span><span style=color:#b48ead> 0</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>        }</span></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>        println!</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>Done!</span><span style=color:#eceff4>");</span></span>
<span class=giallo-l><span style=color:#eceff4>    });</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>// Waiting...</span></span>
<span class=giallo-l><span style=color:#616e88>// Done!</span></span></code></pre><h2 id=9zhang-rotukunoshi-zhuang><a aria-label="Anchor link for: 9zhang-rotukunoshi-zhuang" class=zola-anchor href=#9zhang-rotukunoshi-zhuang>9章ロックの実装</a></h2><p><code>wait()</code>,<code>wake_one()</code>,<code>wake_all()</code>の機能を提供する<a href=https://crates.io/crates/atomic-wait rel=external><code>atomic-wait</code></a>を利用して、<code>Mutex</code>, <code>Condvar</code>, <code>RwLock</code>を実装します。(Mara先生のcrateです)<br> <code>atomic-wait</code>の内部で、Linuxでは<code>SYS_futex</code>, FreeBSDでは<code>_umtx_op</code>, Windowsでは<code>Wait{On,By}Address</code>, macOSでは<code>libc++</code>を利用して、futex類似のapiを抽象化してくれているそうです。<p><code>wait()</code>はsystem callを伴うので、それを呼ぶ前に一定回数spin lockを試みる等の最適化も紹介されます。<br> さらに、spin lockでのloopの中で、compare_exchange等の比較交換操作を読んでしまうと、cache coherenceのprotocol上排他アクセスを要してしまうので、loadで読むようにするといった点も解説されます。<p>futex likeなapiとatomic変数だけで、read lockとwrite lockを提供する<code>RwLock</code>を作れるのは驚きです。<h2 id=10zhang-aideiatoinsupiresiyon><a aria-label="Anchor link for: 10zhang-aideiatoinsupiresiyon" class=zola-anchor href=#10zhang-aideiatoinsupiresiyon>10章 アイディアとインスピレーション</a></h2><p>平行性に関する様々なデータ構造やアルゴリズムが紹介されます。<br> 自分は<a href=https://crates.io/crates/parking_lot rel=external><code>parking_lot</code></a>について知りたいと思っていたので挙げられている<a href=https://webkit.org/blog/6161/locking-in-webkit/ rel=external>参考文献</a>を読んでみよと思いました。<h2 id=zui-hou-ni><a aria-label="Anchor link for: zui-hou-ni" class=zola-anchor href=#zui-hou-ni>最後に</a></h2><p>ということで、Rust Atomics and Locksの翻訳を読んでみました。 日本語翻訳もとても読みやすく、読んでいてとても楽しい本でした。<br> 来年は本書でもでてきた、<code>NonNull</code>,<code>UnsafeCell</code>,<code>ManuallyDrop</code>,<code>MaybUninit</code>等のunsafeなコードも読んでいければなどと思っています。<p><del>著者のMara Bos先生をマラと読んでいましたが、マーラみたいでした。</del></div></article></main><footer class=blog-footer><p>© 2026 <a href=https://blog.ymgyt.io> ymgyt </a> | Made with <a href=https://www.getzola.org rel=noopener target=_blank>Zola</a> | <a href=https://github.com/ymgyt/blog>Repository</a> | <a href=https://blog.ymgyt.io/atom.xml target=_blank title=rss> <svg viewbox="0 0 24 24" class=icon fill=none height=24 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx=5 cy=19 r=1></circle></svg> </a></footer></div></div>