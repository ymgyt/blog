<!doctype html><html lang=ja><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=https://blog.ymgyt.io/favicon.ico rel=icon sizes=any><link href=https://blog.ymgyt.io/icon.svg rel=icon type=image/svg+xml><link href=https://blog.ymgyt.io/apple-touch-icon.png rel=apple-touch-icon><link href=https://blog.ymgyt.io/manifest.webmanifest rel=manifest><link href=https://blog.ymgyt.io/style.css rel=stylesheet><link href=https://blog.ymgyt.io/atom.xml rel=alternate title=Atom type=application/atom+xml><script src="https://www.googletagmanager.com/gtag/js?id=G-GTB0KMLN90" async></script><script>window.dataLayer = window.dataLayer || [];
	function gtag() {dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-GTB0KMLN90');</script><title>📙 RUST FOR RUSTACEANSを読んだ感想 | Happy developing</title><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><body><div class=world><div class=content-container><header class=blog-header-container><div class=blog-logo><a href=https://blog.ymgyt.io>Happy developing</a></div><div class=blog-nav><nav><ul><li><a href=https://blog.ymgyt.io/entry/>Entries</a><li><a href=https://blog.ymgyt.io/tags/>Tags</a><li><a href=https://blog.ymgyt.io/about/>About</a><li><a href=https://github.com/ymgyt> <img alt=Github class=icon src=https://blog.ymgyt.io/images/icon/github.svg> </a><li><a href="https://twitter.com/YAmaguchixt "> <img alt=Twitter class=icon src=https://blog.ymgyt.io/images/icon/twitter.svg> </a></ul></nav></div></header><main class=blog-main><article><header class=entry-header><h1 class=entry-title>📙 RUST FOR RUSTACEANSを読んだ感想</h1><div class=entry-meta><p class=entry-meta-item>🗓 2021-12-31<p class=entry-meta-item>🏷 <span class=tag><a href=https://blog.ymgyt.io/tags/rust/>rust</a></span> <span class=tag><a href=https://blog.ymgyt.io/tags/book/>book</a></span></div></header><aside class=entry-toc><nav><ul class=entry-toc-toplevel-list><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#du-ndaben>読んだ本</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#kitukake>きっかけ</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#matome>まとめ</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#foundations>FOUNDATIONS</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#types>TYPES</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#types-in-memory>Types In Memory</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#traits-and-trait-bounds>Traits and Trait Bounds</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#designing-interfaces>Designing Interfaces</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#unsurprising>Unsurprising</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#flexible>Flexible</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#obvious>Obvious</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#constrained>Constrained</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#error-handling>Error Handling</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#representing-error>Representing Error</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#project-structure>Project Structure</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#testing>Testing</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#rust-testing-mechanisms>Rust Testing Mechanisms</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#additional-testing-tools>Additional Testing Tools</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#macros>Macros</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#declarative-macros>Declarative Macros</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#procedural-macros>Procedural Macros</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#asynchronous-programming>Asynchronous Programming</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#what-s-the-deal-with-asynchrony>What's the Deal with Asynchrony</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#ergonomic-futures>Ergonomic Futures</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#going-to-sleep>Going to Sleep</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#unsafe-code>Unsafe Code</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#the-unsafe-keyword>The unsafe Keyword</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#great-power>Great Power</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#great-responsibility>Great Responsibility</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#concurrency>Concurrency</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#the-trouble-with-concurrency>The Trouble with Concurrency</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#concurrency-models>Concurrency Models</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#lower-level-concurrency>Lower-Level Concurrency</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#sane-concurrency>Sane Concurrency</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#foreign-function-interfaces>Foreign Function Interfaces</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#crossing-boundaries-with-extern>Crossing Boundaries with extern</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#allocation>Allocation</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#safety>Safety</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#rust-without-the-standard-library>Rust Without The Standard Library</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#the-rust-runtime>The Rust Runtime</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#low-level-memory-access>Low Level Memory Access</a></ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#the-rust-ecosystem>The Rust Ecosystem</a> <ul><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#patterns-in-the-wild>Patterns in the Wild</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#staying-up-to-date>Staying Up to Date</a><li><a href=https://blog.ymgyt.io/entry/rust-for-rustacieans/#what-next>What Next?</a></ul></ul></nav></aside><div class=entry-content><h2 id=du-ndaben><a aria-label="Anchor link for: du-ndaben" class=zola-anchor href=#du-ndaben>読んだ本</a></h2><a href=https://nostarch.com/rust-rustaceans> <figure><div class=fig-images-row><img , alt src=images/rust_for_rustaceans.png></div><figcaption>RUST FOR RUSTACEANS</figcaption></figure> </a><p>著者: <a href=https://twitter.com/jonhoo rel=external>Jon Gjengset</a><p>本書を読んだ感想を書いていきます。 この記事で触れていることは本の内容の一部です。<br> 序文で<a href=https://github.com/dtolnay rel=external>dtolnay先生</a>のメッセージが読めます。<h2 id=kitukake><a aria-label="Anchor link for: kitukake" class=zola-anchor href=#kitukake>きっかけ</a></h2><p>もともとJon GjengsetさんのRust動画を<a href=https://www.youtube.com/c/jongjengset rel=external>youtube</a>でみていたので、本もおもしろいにちがいないと思い買いました。<h2 id=matome><a aria-label="Anchor link for: matome" class=zola-anchor href=#matome>まとめ</a></h2><p>非常におもしろかったです! StackとHeapについてから、型やAPI Design、Test,Macro,Async,Pin,Unsafe,Concurrency,FFIと多様なトピックがあり、Rustの開発者の方がどういう風に考えているか垣間見え勉強になりました。 <a href=https://doc.rust-lang.org/book/ rel=external>The Book</a>に書いてあることは前提になっていると思います。 普段の職場ではRustを書いている人がいないので、同僚の方々から口頭で教わるような話が書いてある本は非常に貴重でした。<h2 id=foundations><a aria-label="Anchor link for: foundations" class=zola-anchor href=#foundations>FOUNDATIONS</a></h2><p>Valueとvariableの違いや、variableについて考えるときのメンタルモデルとして、High-LevelとLow-Levelに分けてみることができる。High-Levelの方はborrow checkerやvariable間の関係に焦点をあて、Low-Level的な見方はvariableはmemory locationに名前をつけたと考えると自分なりには理解しました。<p>Codeを書くうえで、memoryのどの部分を利用するかは重要で、Rustに際してはstack, heap, static memoryの区別が特に重要。<br> Stackの考え方は<a href=https://www.sigbus.info/compilerbook rel=external>rui ueyama先生のcompiler book 関数とローカル変数</a>が非常にわかりやすいと思いました。<br> Stack frameはいずれ消える(書き換えられる)ということがlifetimeとして表現されているのがRustの特徴のひとつだなと思いました。<p>Heapはcall stackとは独立したメモリ領域。Rustでheapとやり取りするprimary mechanismは<code>Box</code>。heapに確保した領域はいずれ開放(free)する必要があり、その責務を表現したのがownership。<br> Read-onlyなconfigurationへのアクセスをプログラム全体に提供するために、意図的に<code>Box::leak</code>で、リーク(<code>'static</code>をえる)させることもあると書かれており、この方法は試してみたいです。<p>Static memoryはbinaryに埋め込まれた領域で、static memoryへの参照は<code>'static</code>になる。<br> <code>'static</code> はtrait boundsとしても使われる。(<code>T: 'static</code>) このとき、Tはownedか<code>&'static</code>の参照だけをもつことが要求される。よい例として、<code>std::thread::spawn</code>が挙げられている。<p>Drop orderがvariableの場合はreverse(最後に宣言されたものが最初)で、nested values(struct, tuple, array,..)はsource code順になる理由も説明されており、なるほどでした。<p>Ownership,{Shared,Mutable} References, Interior Mutabilityについても簡潔に説明されていました。<blockquote><p>References are pointers that come with an additional contract for how they can be used</blockquote><p>という説明があり、referenceってpointerって考えていいんだよねと思っていたので参考になりました。 Lifetimeとvarianceの説明もあり、このあたりの話は<a href=https://blog.ymgyt.io/entry/lifetime-and-variance/>以前ブログで書いた</a>ので、理解できました。(どうして、<code>&mut T</code>がTにたいしてinvariantなのか等)<h2 id=types><a aria-label="Anchor link for: types" class=zola-anchor href=#types>TYPES</a></h2><h3 id=types-in-memory><a aria-label="Anchor link for: types-in-memory" class=zola-anchor href=#types-in-memory>Types In Memory</a></h3><p>Typeの最もfundamentalな役割の一つはmemoryのbitsをどう解釈するかを示すことという話。<br> structのfieldやenumがmemoryにどう表現されるかを理解しておくことは、codeのcorrectnessとperformanceに影響するので重要であるようです。<h4 id=alignment><a aria-label="Anchor link for: alignment" class=zola-anchor href=#alignment>Alignment</a></h4><p>typeのメモリ表現が決まっても、そのbitsを任意のメモリに置けるわけではなく、hardware上の制約をうけます。<br> 例として、pointerはbitsでなく必ずbytesを指し示す必要があり、T型の値をメモリの4bit目におくことはできない。つまりどんな型であれ byte 0かbyte 1(bit 8)におく必要があり、その意味で"byte-aligned"(multiple of 8bits)であると説明されています。<h4 id=layout><a aria-label="Anchor link for: layout" class=zola-anchor href=#layout>Layout</a></h4><p>structをメモリ上にどう表現するか(宣言された順当)を決めるのがlayout。<br> Rustのcompilerはこの点に関して、あまり保証を与えてくれず、制御したい場合は<code>repr(C)</code>を使うことができる。<br> <code>repr(C)</code>はC/C++と同じlayoutになることを保証してくれるので、FFIをする際に便利。また、Cのlayoutは予測しやすく変更の対象でないので、raw pointerを扱うunsafeのcontextでも利用できる。<h4 id=dynamically-sized-types-and-wide-pointers><a aria-label="Anchor link for: dynamically-sized-types-and-wide-pointers" class=zola-anchor href=#dynamically-sized-types-and-wide-pointers>Dynamically Sized Types and Wide Pointers</a></h4><p>trait objectやsliceのようにcompile時にメモリ上のサイズがわからない型をDynamically Sized Types(DST)という。 型のサイズがわかっていることはtrait <code>Sized</code>で表現できる。<br> struct fields, 関数の引数、戻り値、local変数、arrayのtype等あらゆるところで、Sizedが要求される。Sizedが要求されるところで、DSTを使うには、wide(fat) pointerを使う。wide pointerはSizedで通常のpointerの情報に加えてword-sizeのfieldをもつ。DSTの参照をとるとcompilerが自動的にwide pointerを生成してくれる。追加で保持する情報は型ごとに異なるが、sliceの場合は長さ、trait objectの場合はvtableへの参照。<h3 id=traits-and-trait-bounds><a aria-label="Anchor link for: traits-and-trait-bounds" class=zola-anchor href=#traits-and-trait-bounds>Traits and Trait Bounds</a></h3><h4 id=compilation-and-dispatch><a aria-label="Anchor link for: compilation-and-dispatch" class=zola-anchor href=#compilation-and-dispatch>Compilation and Dispatch</a></h4><p>型Tに対してstructや関数を書くと、compilerが実際にTとして使われた型(<code>i32</code>, String,...)ごとにimpl blockをコピーしてくれる。このgeneric typeからnon-generic typesへの変換プロセスをmonomorphizationという。 また、compile時に生成されたコードのaddressが決まっていることから、static dispatchともいわれる。<p>static dispatchと対になるのがdynamic dispatch。これは引数に<code>&dyn Trait</code>に書くことで表現できる。この場合、vtableといわれるtraitのmethodの実装へのaddressを保持したchunk of memoryへのpointerを要求することになる。<br> <code>&dyn</code>と書いたのは、trait objectがSizedでないので、pointer経由で扱う必要があるから。<p>staticとdynamicどちらのdispatchを使うべきかについては、明確な基準はないものの、libraryではstatic dispatchを利用しておくとuser側で選択できる余地を残すことができる。binaryなら必要に応じてdynamic dispatchを使うことでgeneric parameterを避けることができたりする。<h4 id=generic-traits><a aria-label="Anchor link for: generic-traits" class=zola-anchor href=#generic-traits>Generic Traits</a></h4><p>traitをgenericにする方法は２つあり、一つは<code>trait From&lt;T></code>のようにtype parameterを使う方法 、もう一つは<code>trait FromStr { type Err; }</code>のようにassociated typeを使う方法。<br> 最初は使い分けがわかっていませんでしたが、<code>From&lt;T></code>のようにある型に複数個実装を生やしたい場合はtype parameter, ある型に対して一つだけ実装を要求する場合はassociated typeと考えるようになりましたが、本でも同様のことが述べられていました。<h4 id=coherence-and-the-orphan-rule><a aria-label="Anchor link for: coherence-and-the-orphan-rule" class=zola-anchor href=#coherence-and-the-orphan-rule>Coherence and the Orphan Rule</a></h4><p>traitの実装に関してはorphan ruleが適用される。orphan ruleとは、traitをある型に実装する際にそのtraitか型がcrateに含まれている必要があるというもの。ただし、orphan ruleの適用例外もありそれがfundamental types。<br> fundamental typesは<code>#[fundamenta]</code> attributeが付与され、現在のところ<code>&</code>, <code>&mut</code>, <code>Box</code>の３つの型がfundamental型とされている。fundamental型に関しては<code>impl IntoIterator for &MyType</code> のような実装が許される。orphan ruleが適用されるとするとこれは外部のtraitを外部の型に実装していることになる。<p>また、<code>impl From&lt;MyType> for Vec&lt;i32></code> のような実装を許すために、限定的な例外規定が設けられている説明があったが、理解できなかったので、いずれ理解したい。<h4 id=trait-bounds><a aria-label="Anchor link for: trait-bounds" class=zola-anchor href=#trait-bounds>Trait Bounds</a></h4><p>trait boundは必ずしも、<code>T: Trait</code>のように書かなければいけないというわけではない。<br> <code>where String: Clone</code>や、<code>where io::Error: From&lt;MyError&lt;T>></code>のように書くこともできる。<br> なので<code>T: Hash + Eq, S: BuilderHasher + Default</code>の代わりに<code>where HashMap&lt;T, usize, S>: FromIterator</code>のような表現もできる。<h4 id=marker><a aria-label="Anchor link for: marker" class=zola-anchor href=#marker>Marker</a></h4><p><code>Send</code>のようなmarker traitに似たものとして、marker typesというパターンがある。<br> 具体的なsample codeは載っていなかったので、こういうものと想像。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>use</span><span> std</span><span style=color:#81a1c1>::</span><span>marker</span><span style=color:#81a1c1>::</span><span style=color:#8fbcbb>PhantomData</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> Unauthenticated</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> Authenticated</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> SshConnection</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> Unauthenticated</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span>    phantom</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> PhantomData</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>impl</span><span style=color:#8fbcbb> SshConnection</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Unauthenticated</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub fn</span><span style=color:#88c0d0> new</span><span style=color:#eceff4>()</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> SshConnection</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Unauthenticated</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span style=color:#8fbcbb>        SshConnection</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>            phantom</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> PhantomData</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>        }</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub fn</span><span style=color:#88c0d0> authenticate</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&self</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> SshConnection</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Authenticated</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span style=color:#8fbcbb>        SshConnection</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>            phantom</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> PhantomData</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>        }</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>impl</span><span style=color:#8fbcbb> SshConnection</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Authenticated</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub fn</span><span style=color:#88c0d0> exec</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&self</span><span style=color:#eceff4>,</span><span> _command</span><span style=color:#81a1c1>: impl</span><span style=color:#8fbcbb> Into</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>String</span><span style=color:#eceff4>>) {}</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> main</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> connection</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> SshConnection</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>new</span><span style=color:#eceff4>();</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> authenticated</span><span style=color:#81a1c1> =</span><span> connection</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>authenticate</span><span style=color:#eceff4>();</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    authenticated</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>exec</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>command</span><span style=color:#eceff4>");</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>stateを型として表現して、stateごとにimplを定義することで、stateごとに呼び出せるmethodを制御する実装方法は非常に参考になり、使ってみたいと思った。<h4 id=existential-types><a aria-label="Anchor link for: existential-types" class=zola-anchor href=#existential-types>Existential Types</a></h4><p>local variableについてはcompilerが推測してくれるので型を明示する必要は少ないが、関数の引数、戻り値、top levelの定義では型を明示することが要求される。ただし、<code>async</code>を使ったり、closureを返す場合等、型を明示することが用意でない場合があるので、こんなときに、戻り値の型を<code>-> impl Trait</code>で書くことができる。<br> existential typesはzero-cost type eraseとしても機能する。iteratorのようにhelper型をinterfaceに含めなくてよくなり、後方互換性を保ちながら実装を変えやすくなる。<h2 id=designing-interfaces><a aria-label="Anchor link for: designing-interfaces" class=zola-anchor href=#designing-interfaces>Designing Interfaces</a></h2><p>どんなprojectでも大小関わらず、なにかしらのinterface(API)をもつが、Rustにおいては特にtype, trait, moduleがinterfaceとして機能する。そこで、Rustにおけるinterfaceを考える際に考慮する原則として以下の４つが提唱されている。<ul><li>unsurprising<li>flexible<li>obvious<li>constrained</ul><p>さらにAPI関連でおすすめのdocumentとして以下が挙げられている。<ul><li><a href=https://rust-lang.github.io/api-guidelines/about.html rel=external>About - Rust API Guidelines</a><li><a href=https://rust-lang.github.io/rfcs/1105-api-evolution.html rel=external>1105-api-evolution</a><li><a href=https://doc.rust-lang.org/cargo/reference/semver.html rel=external>SemVer Compatibility</a></ul><h3 id=unsurprising><a aria-label="Anchor link for: unsurprising" class=zola-anchor href=#unsurprising>Unsurprising</a></h3><p>要はinterfaceをpredictableにするにはどうすればよいかという視点。<h4 id=naming-practices><a aria-label="Anchor link for: naming-practices" class=zola-anchor href=#naming-practices>Naming Practices</a></h4><p>慣習として確立している命名には従う。<ul><li><code>iter()</code> は<code> fn iter(&self) -> impl Iterator</code> (<code>&self</code>とって、Iteratorに実装を返す)<li><code>into_inner()</code> は<code>self</code>とって、wrapされている型を返す<li><code>SomethingError</code>は<code>std::error::Error</code>を実装している</ul><h4 id=common-traits-for-types><a aria-label="Anchor link for: common-traits-for-types" class=zola-anchor href=#common-traits-for-types>Common Traits for Types</a></h4><p>orphan ruleによりlibraryのuserはlibrary側の型にstdで定義されているtraitを実装できないので、一般的なtraitは可能であれば実装されていることを期待している。(自前の型でwrapすればできるが、それでもinternalにアクセスできないので実装が難しくなる)<p>代表格が<code>Debug</code>。型名を出力するだけでもよいから、実装しておくのがおすすめされている。<code>Debug</code>の実装をfeatureに切り出しているcrateは何度か見たことがあった。<br> 僅差で2位が、<code>Send</code>,<code>Sync</code>(と<code>Unpin</code>)のauto-traits。もし型がこれらのtraitを実装しないならそれなりの理由があるべき。 次にnearly universalなtraitが<code>Clone</code>と<code>Default</code>。仮に実装できないなら、理由をドキュメントに書いておく。 期待されるtraitとしてちょっと優先度下がるが、可能なら<code>PartialEq</code>, <code>PartialOrd</code>, <code>Hash</code>, <code>Eq</code>, <code>Ord</code>もほしい。<br> <code>PartialEq</code>は<code>assert_eq!</code>で使って後から付け足すことが多かったです。 最後に、<code>serde::{Serialize,Deserialize}</code>も実装しておくとよいが、<code>serde</code>へ依存したくない場合もあるので、多くのlibraryではfeatureで制御している。<p>以上が一般的に実装されているのが期待されているtraitでしたが、反対に<code>Copy</code>は実装されていないほうが期待されているtrait。copyしたければ、明示的にcloneを呼べば良いし、最初は<code>Copy</code>だったstructが<code>Copy</code>じゃなくなる(fieldにString追加等)ことは後方互換性を破壊する変更なので、<code>Copy</code>は通常はつけないほうがいい。<h4 id=ergonomic-trait-implementations><a aria-label="Anchor link for: ergonomic-trait-implementations" class=zola-anchor href=#ergonomic-trait-implementations>Ergonomic Trait Implementations</a></h4><p>ある型Tにtraitを実装した場合でも、&Tにそのtraitは自動的に実装されない。 traitが<code>&self</code>しかとらない場合<code>&T</code>にそのtraitが実装されていることをユーザは期待する。<p>そこで可能なら以下のblanket implementationを提供しておくとよい<ul><li><code>&T where T: Trait</code><li><code>&mut T where T: Trait</code><li><code>Box&lt;T> where T: Trait</code></ul><p>iterateできる型であれば、<code>&MyType</code>と<code>&mut MyType</code>にそれぞれ <code>IntoIterator</code>を実装してfor loopで自然に使えるようにしておく。<h4 id=wrapper-types><a aria-label="Anchor link for: wrapper-types" class=zola-anchor href=#wrapper-types>Wrapper Types</a></h4><p>Rustは継承という概念をもっていないが、<code>Deref</code>を使って、同様の機能を実現している。<br> <code>T: Deref&lt;Target = U></code>ならUに実装されているmethodを直接Tの値をreceiverとして呼ぶことができる。<p><code>Arc</code>のような比較的透過的なwrapper型を提供しているなら、<code>Deref</code>を定義してinner typeの へ<code>.</code>でアクセスできるようにしておくとよい。 inner typeへのアクセスが複雑であったり遅くなったりしない場合<code>AsRef</code>を実装しておくと ユーザが容易に<code>&WrapperType</code>を<code>&InnerType</code>として扱えるようになる。 <code>From&lt;InnerType></code>と<code>Into&lt;InnerType></code>を実装しておくと、ユーザがwrapper型にくるんだり剥がしたりしやすくなる。<p><code>Borrow</code>の場合は、<code>AsRef</code>よりユースケースが限定的で、追加の要求がある(<code>Hash</code>, <code>Eq</code>, <code>Ord</code> に関して同じように振る舞う)<p>inner typeが事前にわからない場合、wrapperにmethodを定義すると、deref先のinner type のmethodと衝突する可能性があるので、<code>Arc</code>のようにstatic methodベースにしておくとよかったりする<h3 id=flexible><a aria-label="Anchor link for: flexible" class=zola-anchor href=#flexible>Flexible</a></h3><p>codeは暗黙的にせよ明示的にせよcontractを含む。 contractはrequirementsとpromisesからなる。 requirementsはそのcodeの使われ方に制約を課し、promisesはそのcodeがどう使えるかに 保証を与える。<p>できるだけ不必要なrequirementsをなくし、できるpromiseだけをするのがよい。 追加のrequirementsや、promisesを取りぞくことはbreaking changeとなる。<br> 逆に、requirementsを緩和したり、promisesを追加することは互換性をたもつ変更になる。<p>Rustではrequirementsはtrait boundや引数の型として表現され、promisesは関数の戻り値の型で表現される。<h4 id=object-safety><a aria-label="Anchor link for: object-safety" class=zola-anchor href=#object-safety>Object Safety</a></h4><p>新しいtraitを定義した際に、そのtraitがobject-safeかどうかは書かれざるcontractになる。 object-safeである場合、ユーザは<code>dyn Trait</code>のようにtrait objectとしてそのtraitを扱うので<p><code>where Self: Sized</code>と書くと、そのtraitはtrait objectからは呼ばれず、必ずconcrete typeに呼ばれることを強制できる。<p>trait objectについては実装したことがないので、いまいち実感がわかず。 このあたり苦労したことがあると書いてあることがわかるかもしれないと思いました。<h4 id=borrowed-vs-owned><a aria-label="Anchor link for: borrowed-vs-owned" class=zola-anchor href=#borrowed-vs-owned>Borrowed vs. Owned</a></h4><p>なにかしらのtraitや型を定義する際に、Rustにおいてはownedかreferenceで保持するのかの選択を迫られる。<br> まずその型の<code>self</code>をとるmethodを呼んでいたり、別のthreadにmoveしたりする必要がある場合はownedを選択することになる。<br> ownedする必要がない場合はreferenceを使うことになるが、<code>i32</code>や<code>bool</code>等はmoveするのと、参照経由でcopyするコストは同程度なので例外になる。<br> ただし、<code>[u8; 8192]</code>も<code>Copy</code>なので、<code>Copy</code>なら全部そうというわけでもない。<br> <code>String::from_utf8</code>のようにruntimeでownedかreferenceかわかるような場合は<code>Cow</code>が便利。<h4 id=fallible-and-blocking-destructors><a aria-label="Anchor link for: fallible-and-blocking-destructors" class=zola-anchor href=#fallible-and-blocking-destructors>Fallible and Blocking Destructors</a></h4><p>I/O関連のcleanup処理(flush write, close disk,terminate connection)は 一般的には<code>Drop</code>の実装の中でなされる。<br> しかし、一度valueがdropしてしまうと、<code>Drop</code>の処理の中でおきたエラーを伝播させる 方法はpanicさせるくらいしかなくなってしまう。<p>ユーザに明示的にdestructor処理を公開する代替手段が考えられる。その場合ownershipをtakeする(<code>self</code>をとる)methodになるが その場合<code>Drop</code>があるので、fieldをmoveさせることはできない。<br> また、<code>Drop</code>自体は<code>&mut self</code>をとるので、<code>Drop</code>の中から<code>self</code>をとるdestructorをよぶことができない。<br> もちろん回避策はあるが、いずれにもなにかしらの欠点がある。(trade-off) １つ目はwrapper型を用意して、inner型をOptionにして、destructorの中で<code>Option::take</code>する。 ２つ目は各fieldをOptionでwrapする方法。 ３つ目は<code>ManuallyDrop</code>を使う方法。<h3 id=obvious><a aria-label="Anchor link for: obvious" class=zola-anchor href=#obvious>Obvious</a></h3><p>通常、ユーザはmethod <code>baz</code>を呼んでも大丈夫なのは月の角度が47度で、過去18秒間に誰もくしゃみをしなかった場合だけというのを理解していない。<br> 何かおかしなことがおきたときだけ、ドキュメントを呼んだりsignatureを確認したりするもの。<br> したがって、ユーザのインターフェイスへの理解を助け、間違って使用されないようにすることが重要で、そのための手段としてドキュメントと型システムがある。<h4 id=documentation><a aria-label="Anchor link for: documentation" class=zola-anchor href=#documentation>Documentation</a></h4><p>よいdocumentについてで本一冊かけるので、Rustに絞った話。<br> unexpectedな挙動をする場合や、type signatureで表現されていないuserへの期待がある場合はdocumentに書かれているべき。<br> panicはよい例。errorを返す場合はどんな場合かについて記述する。unsafe functionの場合は、callerが保証すべきことがらについて書く。<p>end-to-endのexampleをmodule levelのdocumentに書いておくのがよい。全体像がつかめると個別の型やmethodの使い所もわかり、userのcodeへの組み込みの出発点になる。<p>semantically relatedなitemはmoduleを活用してグルーピングしておく。<br> 互換性等の理由でしかたなく公開している型には<code>#[doc(hidden)]</code>をつけておくとよい。<p>外部のリソース(RFC, blog, white paper等)へのlinkを付与する。featureで制御している機能には`#[doc(cfg..)]をつけておくと親切。<h4 id=type-system-guidance><a aria-label="Anchor link for: type-system-guidance" class=zola-anchor href=#type-system-guidance>Type System Guidance</a></h4><p>type systemはinterfaceをobviousにし、misuse-resistantを高めるのに適している。<p>そのための手段として、semantic typingがある。classic exampleとして、boolを引数をとる関数に対して<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub enum</span><span style=color:#8fbcbb> Overwrite</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#8fbcbb>  Yes</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#8fbcbb>  No</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub enum</span><span style=color:#8fbcbb> DryRun</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#8fbcbb>  Yes</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#8fbcbb>  No</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>pub fn</span><span style=color:#88c0d0> foo</span><span style=color:#eceff4>(</span><span>overwrite</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> Overwrite</span><span style=color:#eceff4>,</span><span> dry_run</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> DryRun</span><span style=color:#eceff4>) {</span><span style=color:#88c0d0;font-weight:700> todo!</span><span style=color:#eceff4>() }</span></span></code></pre><p>のようにenumをきることで、userがoverwriteとdry runの指定を間違う可能性をへらすことができる。<br> その他にもnewtype patternでnumeric typeをwrapして単位をもたせたり、別の関数からのみ取得できる型で、raw pointerをwrapしたり方法もある。<p>関連したテクニックとして、zero-sized typeを使って、特定の状態を表すことができる。<br> 特定の状態のときにだけ呼べるmethodを定義したい場合、例えば以下のように書ける<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> Grounded</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> Launched</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#616e88>// and so on</span></span>
<span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> Rocket</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Stage</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> Grounded</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span>  stage</span><span style=color:#81a1c1>:</span><span> std</span><span style=color:#81a1c1>::</span><span>marker</span><span style=color:#81a1c1>::</span><span style=color:#8fbcbb>PhantomData</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Stage</span><span style=color:#eceff4>>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>impl</span><span style=color:#8fbcbb> Default</span><span style=color:#81a1c1> for</span><span style=color:#8fbcbb> Rocket</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Grounded</span><span style=color:#eceff4>> {}</span><span> </span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>impl</span><span style=color:#8fbcbb> Rocket</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Grounded</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub fn</span><span style=color:#88c0d0> launch</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>self</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> Rocket</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Launched</span><span style=color:#eceff4>> {</span><span style=color:#88c0d0;font-weight:700> todo!</span><span style=color:#eceff4>() }</span><span> </span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>impl</span><span style=color:#8fbcbb> Rocket</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Launched</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub fn</span><span style=color:#88c0d0> accelerate</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&mut self</span><span style=color:#eceff4>) { }</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub fn</span><span style=color:#88c0d0> decelerate</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&mut self</span><span style=color:#eceff4>) { }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>impl</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Stage</span><span style=color:#eceff4>></span><span style=color:#8fbcbb> Rocket</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Stage</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub fn</span><span style=color:#88c0d0> color</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&self</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> Color</span><span style=color:#eceff4> { }</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub fn</span><span style=color:#88c0d0> weight</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&self</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> Kilograms</span><span style=color:#eceff4> { }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>特定の場合にだけ、追加で引数が必要になる場合は、それぞれの状況をenumで表しておくのもよい。<br> 必要なら<code>#[must_use]</code>を付与して、<code>Result</code>同様に呼び出し側に戻り値のハンドリングを強制(警告)することもできる。<p>特定の場合にだけ、追加で引数が必要になる場合は、それぞれの状況をenumで表しておくのもよい。<br> 必要なら<code>#[must_use]</code>を付与して、<code>Result</code>同様に呼び出し側に戻り値のハンドリングを強制(警告)することもできる。<h3 id=constrained><a aria-label="Anchor link for: constrained" class=zola-anchor href=#constrained>Constrained</a></h3><p>型のrenameやmethodの削除のような変更がbackward incompatible changeであることは明らかだが、Rust特有のものもある。<h4 id=type-modifications><a aria-label="Anchor link for: type-modifications" class=zola-anchor href=#type-modifications>Type Modifications</a></h4><p>public typeのremove/renameはuser codeを破壊するので、可能な限り<code>pub(crate)</code>,<code>pub(in path)</code>をつけるとよい。<br> public typeが少なければ少ないほど、codeを破壊することなく変更できる自由をえられる。<p>private fieldのstructへの追加でもuserのconstructor表現を破壊する可能性がある。<br> <code>matches!</code>で使われていたりする場合も同様。<p>こんなときは<code>#[non_exhaustive]</code>を付与しておくと、将来的なfieldの追加可能性を宣言できるので便利。<h4 id=trait-implementations><a aria-label="Anchor link for: trait-implementations" class=zola-anchor href=#trait-implementations>Trait Implementations</a></h4><p>blanket implementationを追加することは一般的にbreaking change。<br> 外部のtraitを既存の型に実装することも、既存のtraitを外部の型に実装することも同様にbreaking change。<p>traitへの変更でbreaking changeを避けるために<code>sealed trait</code>を使うことができる。<br> <code>sealed trait</code>はimplすることができず、useのみできる。<br> <code>sealed trait</code>を利用しておくと、安全にtraitにmethodを追加することができる。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub trait</span><span style=color:#8fbcbb;font-weight:700> CanUseCannotImplement</span><span style=color:#81a1c1>:</span><span> sealed</span><span style=color:#81a1c1>::</span><span style=color:#8fbcbb>Sealed</span><span style=color:#eceff4> {</span><span style=color:#81a1c1> ..</span><span style=color:#eceff4> }</span><span> </span></span>
<span class=giallo-l><span style=color:#81a1c1>mod</span><span> sealed</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub trait</span><span style=color:#8fbcbb;font-weight:700> Sealed</span><span style=color:#eceff4> {}</span></span>
<span class=giallo-l><span style=color:#81a1c1>    impl</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>></span><span style=color:#8fbcbb> Sealed</span><span style=color:#81a1c1> for</span><span style=color:#8fbcbb> T</span><span style=color:#81a1c1> where</span><span style=color:#8fbcbb> T</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> TraitBounds</span><span style=color:#eceff4> {}</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>impl</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>></span><span style=color:#8fbcbb> CanUseCannotImplement</span><span style=color:#81a1c1> for</span><span style=color:#8fbcbb> T</span><span style=color:#81a1c1> where</span><span style=color:#8fbcbb> T</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> TraitBounds</span><span style=color:#eceff4> {}</span></span></code></pre><p>このようにしておくと、super traitがprivate module配下にあるため、<code>CanUseCannotImplement</code> traitの実装を制御できる。<h4 id=hidden-contracts><a aria-label="Anchor link for: hidden-contracts" class=zola-anchor href=#hidden-contracts>Hidden Contracts</a></h4><p>codeへの変更が他の部分のcontractに影響する場合がある。<br> 他のcrateのtypeをexportしていた場合、そのcrateのmajor versionの変更はbreaking changeになる可能性がある。<br> newtype pattern等でwrapしておくとこの事態を回避できる。<p>publicなstruct Aの中にprivateな型Bをもっている場合で、Bが<code>Send</code>でなくなった場合、Aも<code>Send</code>でなくなり、breaking changeになる。<br> この変更を検知するのは難しいので、以下のようなtestを書いておくとよい。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> is_normal</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> Sized</span><span style=color:#81a1c1> +</span><span style=color:#8fbcbb> Send</span><span style=color:#81a1c1> +</span><span style=color:#8fbcbb> Sync</span><span style=color:#81a1c1> +</span><span style=color:#8fbcbb> Unpin</span><span style=color:#eceff4>>() {}</span></span>
<span class=giallo-l><span style=color:#5e81ac>    #[test]</span></span>
<span class=giallo-l><span style=color:#81a1c1>    fn</span><span style=color:#88c0d0> normal_types</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#88c0d0>      is_normal</span><span style=color:#81a1c1>::</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>MyType</span><span style=color:#eceff4>>();</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><h2 id=error-handling><a aria-label="Anchor link for: error-handling" class=zola-anchor href=#error-handling>Error Handling</a></h2><p>error handlingのbest practicesは議論されているトピックで、ecosystemがひとつに統一されているわけではないので<br> underlying principles and techniquesについて。<h3 id=representing-error><a aria-label="Anchor link for: representing-error" class=zola-anchor href=#representing-error>Representing Error</a></h3><p>errorを返す関数を書く際に最初に問うべきは、そのerrorをユーザがどう扱うかについて。<br> errorの種別を特定したいのか、loggingのみにとどまるのか。<p>errorを表現する際に主にenumerationかerasureの２つの選択肢がある。<h4 id=enumeration><a aria-label="Anchor link for: enumeration" class=zola-anchor href=#enumeration>Enumeration</a></h4><p>callerがerrorの種別を特定できるように<code>enum MyError</code>を定義する。<br> ecosystemと協調できるようにこのenumに<code>std::error::Error</code>を実装する。 <code>Display</code>では簡潔に表現し、他のerror messageに組み込まれることを意識する。<br> <code>Debug</code>ではできるだけ詳細な情報を含めるとよい(port number, request identifier, filepath, ...) multithreadのcontextでも使えるように<code>Send</code>,<code>Sync</code>にしておくとよい。<br> 可能な限り<code>'static</code>にしておくとcallerがlifetime issueに直面せず扱いやすい。<h4 id=opaque-errors><a aria-label="Anchor link for: opaque-errors" class=zola-anchor href=#opaque-errors>Opaque Errors</a></h4><p>enumを定義する代わりにlibraryで一つだけのerror型を定義する方法。<br> <code>Box&lt;dyn Error + Send + Sync + 'static></code>としておくと最小限のことのみuserに保証できる。<p>一般的なcommunity consensusは、errorは稀であるべきで、"happy path"にcostをついかするべきでない。そのため、errorはpointer type(<code>Box</code>,<code>Arc</code>)で表現され、<code>Result</code>のsizeを増加させにくいようにしている。<p><code>'static</code> boundをerror trait objectに付与する利点として、ユーザがpropagateしやすい以外にdowncastingを可能にする点があげられる。errorのcontextにおけるdowncastingは<code>dyn Error</code>型から具体型への変換を意味する。 <code>Error::downcast_ref</code>は<code>dyn Error + 'static</code>にimplされているので<code>'static</code> boundを付与した場合のみ利用できる。<br> downcastingされる具体型がAPIに含まれるかは議論の余地があるポイント。<h4 id=special-error-cases><a aria-label="Anchor link for: special-error-cases" class=zola-anchor href=#special-error-cases>Special Error Cases</a></h4><p><code>std::thread::Result</code>は<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>pub type</span><span style=color:#8fbcbb> Result</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>></span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> Result</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>T</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> Box</span><span style=color:#eceff4>&lt;</span><span style=color:#81a1c1>dyn</span><span style=color:#8fbcbb> Any</span><span style=color:#81a1c1> +</span><span style=color:#8fbcbb> Send</span><span style=color:#81a1c1> +</span><span style=color:#eceff4> '</span><span style=color:#8fbcbb>static</span><span style=color:#eceff4>>>;</span></span></code></pre><p>と定義されており、<code>dyn Error</code>のかわりに<code>Any</code>が使われている。<br> これは<code>Result::Err</code> variantは<code>panic!()</code>でのみ作られ、<code>panic</code>マクロの引数になるから。<br> そのため、panicしたという事実以上のものは型では保証されていない。<h2 id=project-structure><a aria-label="Anchor link for: project-structure" class=zola-anchor href=#project-structure>Project Structure</a></h2><p>Cargo.tomlやconditional compilation関連について。<br> 使ったことのない機能やtoolも紹介されておりとても参考になった。 このあたりの話を知ってからlibraryを読みたかった。 そのほかMinimum Supported Rust Version(MSRV)やChangelogsについても。<h2 id=testing><a aria-label="Anchor link for: testing" class=zola-anchor href=#testing>Testing</a></h2><h3 id=rust-testing-mechanisms><a aria-label="Anchor link for: rust-testing-mechanisms" class=zola-anchor href=#rust-testing-mechanisms>Rust Testing Mechanisms</a></h3><p>Rustがtestを実行する仕組みについて。<br> test時にのみ利用できるcodeを用意することで、public APIのbehavior以外にinternal stateについてもtestできる。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> MyStruct</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>    state</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> usize</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>impl</span><span style=color:#8fbcbb> MyStruct</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#5e81ac>    #[cfg(test)]</span></span>
<span class=giallo-l><span style=color:#81a1c1>    pub</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>crate</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> fn</span><span style=color:#88c0d0> state</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&self</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -> &</span><span style=color:#8fbcbb>usize</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>        &self.</span><span>state</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#5e81ac>#[test]</span></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> initial</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> s</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> MyStruct</span><span style=color:#eceff4>{</span><span>state</span><span style=color:#81a1c1>:</span><span style=color:#b48ead> 0</span><span style=color:#eceff4>};</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>    assert_eq!</span><span style=color:#eceff4>(</span><span>s</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>state</span><span style=color:#eceff4>(),</span><span style=color:#81a1c1> &</span><span style=color:#b48ead>0</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>そのほか、test時にだけfieldを追加できたりもするが、fieldの追加なんかはやりすぎに注意だと思った。<h3 id=additional-testing-tools><a aria-label="Anchor link for: additional-testing-tools" class=zola-anchor href=#additional-testing-tools>Additional Testing Tools</a></h3><p>clippyにはcorrectnessに分類される、ほぼbugと思われるcodeを検出することもできるので、CI等で実行されるようにしておくべき。<p>randomなinputを生成するfuzzingによるtest方法については知りませんでした。使い所があれば是非とりいれてみたいと思いました。最初に触るなら<code>cargo-fuzz</code>がオススメされています。<p>property-based testについても初耳でした。こちらについては<code>proptest</code>crateがオススメされています。<p>race condition等によりnondeterministicなerrorに対応するために、MiriやLoomが紹介されています。Loomはtokioのtest codeで使われていたような気がします。<p>また、codeの変更によりある処理が100倍遅くなる場合だけでなく、100倍速くなるのもbugかもしれないので(なにかが抜けてる)、CIにperformance計測を設定しておくことについて言及されています。<h2 id=macros><a aria-label="Anchor link for: macros" class=zola-anchor href=#macros>Macros</a></h2><p>Rustのmacroはfar from the Wild West of C macrosで、well-defined rulesに従い、fairly misuse-resistantと紹介されている。<h3 id=declarative-macros><a aria-label="Anchor link for: declarative-macros" class=zola-anchor href=#declarative-macros>Declarative Macros</a></h3><p><code>macro_rules!</code>で定義するやつ。<br> どうしてあのmacroがdeclarativeと言われるかというと、inputがこういう場合はoutputがこうなると定義してある点を捉えているからしい。(複雑なやつは手続き的ではと思うがそれでも十分宣言的だと言われればそうかもと思ってしまう)<p>macroへのinputに関してはRustのvalidなcodeでなくてもよいが、compilerがparseできるものでなくてはならない。(<code>{</code>だけを渡す等)<p>Rustのmacroはhygienicと言われるが実のところそれがなにを意味するのかよくわかっていませんでした。(Cみたいに何でもできるわけではないらしい程度) hygienicとは、(generally) 明示的に渡された変数以外には影響を与えられない。と説明されています。<h3 id=procedural-macros><a aria-label="Anchor link for: procedural-macros" class=zola-anchor href=#procedural-macros>Procedural Macros</a></h3><p>与えられたinput tokenに対してhow generateを定義するので、proceduralと言われる。<br> function-like, attribute, deriveの3種類に分類でき、それぞれのユースケースの説明。 中心になるのは<code>TokenStream</code>型で、<code>TokenTree</code>をiterateできる。<code>syn</code>crateでparseすることで、RustのASTを得られる。<br> <code>span</code>を利用するとmacroのエラーをわかりやすく表示できたり、declarative macroのhygieneを実現できたりするらしい。<h2 id=asynchronous-programming><a aria-label="Anchor link for: asynchronous-programming" class=zola-anchor href=#asynchronous-programming>Asynchronous Programming</a></h2><h3 id=what-s-the-deal-with-asynchrony><a aria-label="Anchor link for: what-s-the-deal-with-asynchrony" class=zola-anchor href=#what-s-the-deal-with-asynchrony>What's the Deal with Asynchrony</a></h3><p>asynchronousなprogramを説明するために、synchronousなprogramをthreadと関連して説明してくれている。<br> asynchronous interfaceでは、処理が完了していないことを<code>Poll</code>で表現し、処理がどこまで完了したかの状態が保持されているので、処理が進行できる準備が整ってから再開できるように呼び出し側が制御できる。<br> なので、loopで必要なtaskを実行し、<code>Poll::Pending</code>が返ってきたら別のtaskを実行することで、blockingせずに常に処理を継続することができる。<br> ただし、loopするということは、OSがthreadをsleepしてくれなくなるので、自前でCPU使い切らないように制御する必要がでてくる。<p>asynchronousな世界では、blockしうる関数はそれぞれ<code>poll</code>を実装する必要があるが、そのsignatureがそれぞれ違っては困る。ので、<code>Future</code> traitで<code>poll</code>のsignatureが定められている。<h3 id=ergonomic-futures><a aria-label="Anchor link for: ergonomic-futures" class=zola-anchor href=#ergonomic-futures>Ergonomic Futures</a></h3><p>asyncと書くと生成されるcodeを手で書くとどうなるかの説明があります。<br> async fnの中で<code>await</code>を使うたびに、そこから処理を再開できるようにenumでlocal変数に対応したstateをもつvariantが生成され、そのenumに<code>poll</code>が実装される感じでしょうか。<p>async/await実装のbaseになっているgeneratorについても触れられています。<br> generatorにせよ、enumによるstateにせよ、内部的な状態をstructのfield的に保持します。そうするとそのstructがmoveしてmemory上の位置が変わった場合、structのfieldAを参照しているfieldBがあった場合、そのBの値(メモリの位置)が不正なものになってしまいます。これがself-referentialといわれ、この事態に対処するために<code>Pin</code>型と<code>Unpin</code> traitが用意されています。<p>pin/Unpinについては<a href=https://tech-blog.optim.co.jp/entry/2020/03/05/160000 rel=external>RustのPinチョットワカル </a>が非常にわかりやすかったです。 あとは<a href=https://fasterthanli.me/articles/pin-and-suffering rel=external>Amos先生のPin and suffering</a><h3 id=going-to-sleep><a aria-label="Anchor link for: going-to-sleep" class=zola-anchor href=#going-to-sleep>Going to Sleep</a></h3><p><code>Future::poll</code>が<code>Poll::Pending</code>を返したとき、もう一度futureをpollする必要がある。<br> これを行うのがexecutorとよばれる。executorはloopですべてのfutureをpollし続け、すべてのfutureが<code>Poll::Ready</code>を返すまでまつことでも実装できるが、それだとCPU cycleを浪費してしまう。<br> そこで、なんらかのfutureが状態をすすめられるまで、待機してからpollする仕組みが必要となる。<h4 id=waking-up><a aria-label="Anchor link for: waking-up" class=zola-anchor href=#waking-up>Waking Up</a></h4><p>futureの状態が進められるかをチェックする条件は多岐に渡る(network packetがこのportにきたら、mouse cursorが動いたら、channelにsendされたら、一定時間過ぎたら、...)ので、Rustはexecutorにprogressが可能だと通知できる仕組み、<code>Waker</code>を用意している。<br> <code>Waker</code>はexecutorが用意して、<code>Context</code>経由で、<code>poll</code>時にfutureに渡す。<br> <code>Waker</code>の<code>wake</code>がよばれたときに何が起きるかはexecutorに委ねられており、手動でvtableを実装する形で実装されている。<h4 id=fulfilling-the-poll-contract><a aria-label="Anchor link for: fulfilling-the-poll-contract" class=zola-anchor href=#fulfilling-the-poll-contract>Fulfilling the Poll Contract</a></h4><p><code>Future::poll</code>が<code>Poll::Pending</code>を返したら、次に状態を進められるようになったときに、<code>Waker</code>の<code>wake</code>を呼び出すのはfutureの責務となる。<br> ほとんどのfutureは他のfutureが<code>Poll::Pending</code>を返したときに、<code>Poll::Pending</code>を返せば、他のfutureが責務に従っている限り自身の責務を果たせる。<br> process外のリソース(TCP,disk,...)と直接やりとりするfuture(leaf future)がloopで待機することがないようにOSと協調できるようにする仕組みが必要となるが、それはexecutorに委ねられている。<br> 一般的なexecutorの概要についても説明されていますが、自分の理解力では及びませんでした。<br> executorがsleepする前に、<code>epoll</code>等を使って外部リソースの変更を適切にleaf futureに伝播させるような感じなのでしょうか。<h2 id=unsafe-code><a aria-label="Anchor link for: unsafe-code" class=zola-anchor href=#unsafe-code>Unsafe Code</a></h2><p><code>unsafe</code>が何であり、何でないかについて。<code>unsafe</code>とは、開発者がcompilerがチェックできないinvariantsを利用するためのmechanismということを伝えたい。<br> ところで、invariantsとはなにかというと、programが正しく動くために真でなければいけないもののfancy way of sayingくらいの意味のようです。(<code>&</code>はdanglingしないとか、head pointerはつねにtail pointerより進んでいる等)<br> <code>unsafe</code>に含まれるcodeが安全でないのではなく、特定のcontextでは安全な操作であるため実行することが許可されている。<h3 id=the-unsafe-keyword><a aria-label="Anchor link for: the-unsafe-keyword" class=zola-anchor href=#the-unsafe-keyword>The unsafe Keyword</a></h3><p><code>unsafe</code>というkeywordには２つの役割がある。<ul><li>特定の関数を<code>unsafe</code>にする<li>code blockでunsafe functionalityを使えるようにする</ul><p>unsafe keywordを含んでいない関数でもunsafeを付与することができる。逆にunsafeを含んでいてもunsafeを関数に付与しなくてもよい。<p>昔はunsafe fnは暗黙的に関数bodyがすべてunsafe blockになっていたが、<a href=https://github.com/rust-lang/rfcs/blob/master/text/2585-unsafe-block-in-unsafe-fn.md rel=external>RFC2585</a>で、明示的にunsafe blockを宣言するように修正された経緯がある。<h3 id=great-power><a aria-label="Anchor link for: great-power" class=zola-anchor href=#great-power>Great Power</a></h3><p><code>unsafe {}</code>の中でできるようになることは(他にもあるが、メインは)<ul><li>raw pointerのdereference<li>unsafe fnの呼び出し</ul><h4 id=juggling-raw-pointers><a aria-label="Anchor link for: juggling-raw-pointers" class=zola-anchor href=#juggling-raw-pointers>Juggling Raw pointers</a></h4><p><code>*const T</code>と<code>*mut T</code>はraw pointerと呼ばれる。(rawがつくのは<code>&</code>をpointerと捉えている開発者が多いから)。<br> 参照(<code>&</code>)と違い、lifetimeを持たず、validity ruleが適用されない。<br> raw pointerのほうが適用されるruleが緩いので、<code>unsafe {}</code>の外でも、参照からraw pointerへの変換は実行できる。<h4 id=calling-unsafe-functions><a aria-label="Anchor link for: calling-unsafe-functions" class=zola-anchor href=#calling-unsafe-functions>Calling Unsafe Functions</a></h4><p>unsafeな関数を呼ぶ場面は大別すると3つになる<ul><li>FFI(interact with non-Rust interfaces)<li>skip safety checks(sliceのlen確認せずにindex accessしたり)<li>custom invariantsをもつ関数(例としてあげられている処理、他にももっとある) <ul><li><code>MaybeUninit::assume_init</code><li><code>ManuallyDrop::drop</code></ul></ul><h3 id=great-responsibility><a aria-label="Anchor link for: great-responsibility" class=zola-anchor href=#great-responsibility>Great Responsibility</a></h3><p><code>unsafe</code>でなんでもできるとすると、そもそも<code>unsafe</code>の中で守らなければいけないsafeとはなにかが問題になってくる。この点については、Unsafe Code Guidelines Working Groupが活動中で、明確な線引を策定中らしい。<p>unwindとdrop時のことまで考えると本当にunsafeなコードを書くのは難しそうだと思いました。<br> 特にgenericsが絡むと、一時的にunsafeを使って、不整合な状態する、<code>T::foo()</code>のようなtrait boundのコードを呼ぶ -> panicする -> unwindで、不整合な状態でdrop処理がはじまる。のようなケース。<p>Drop checkまわりの話はまったくわかっていないです、特にDrop checkを通すために、<code>PhantomData</code>でgenericsを消費させたりするところです。このあたりはnomiconに挑戦して理解したいです。<h2 id=concurrency><a aria-label="Anchor link for: concurrency" class=zola-anchor href=#concurrency>Concurrency</a></h2><p>本章でconcurrencyとは、things running more or less at the same timeくらいの意味。<br> tread safetyが型システムでチェックされるのがRustの特徴。<h3 id=the-trouble-with-concurrency><a aria-label="Anchor link for: the-trouble-with-concurrency" class=zola-anchor href=#the-trouble-with-concurrency>The Trouble with Concurrency</a></h3><p>concurrent programのなにが難しいのか、しばしば意図どおりのperformanceが得られない理由がある。 下手をしたらsingle threadで処理したほうが速くなるケースもあり得る。<h3 id=concurrency-models><a aria-label="Anchor link for: concurrency-models" class=zola-anchor href=#concurrency-models>Concurrency Models</a></h3><h4 id=shared-memory><a aria-label="Anchor link for: shared-memory" class=zola-anchor href=#shared-memory>Shared Memory</a></h4><p>thread間でregions of memoryを共有するモデル。<code>Mutex</code>やconcurrent hash mapを利用してstateを共有する。<br> 状態の変更に際してthread間で協調する必要がある場合(state sのthread1の更新処理fとthread2の更新処理gにおいてf(g(s)) != g(f(s)))このモデルが適している。<h4 id=worker-pools><a aria-label="Anchor link for: worker-pools" class=zola-anchor href=#worker-pools>Worker Pools</a></h4><p>Worker Pool modelでは、共有job queueからidenticalなworker threadがjobを実行する。<br> このmodelではwork stealingが鍵になる。<h4 id=actors><a aria-label="Anchor link for: actors" class=zola-anchor href=#actors>Actors</a></h4><p>actor modelではjobの種別ごとにそれぞれjob queueをもつ。actorはそれぞれのstate(resource)へのexclusive accessをもつので、lockやsynchronization mechanismsが必要なくなる。<h3 id=lower-level-concurrency><a aria-label="Anchor link for: lower-level-concurrency" class=zola-anchor href=#lower-level-concurrency>Lower-Level Concurrency</a></h3><p>Atomic(<code>std::sync::atomic::{AtomicUsize,AtomicBool,Ordering}</code>)は複数のthreadがアクセスした際の挙動を制御するsemanticsを定めている。<br> programでvariableに対して値を読んだり書いたりする際、どのようなCPU instructionを生成するかcompilerは自由に制御できる。そこでは、statementsのreorderingや、冗長な処理の省略、memoryの代わりにregisterを使うといったことが含まれる。<br> compilerやCPUはprogramの結果のsemanticsに影響を与えない範囲で、codeを変換できる。<br> しかし、並列実行の文脈ではこの種の変換がapplication behaviorに影響を与えるので、なんらかの方法で制約を伝える必要がある。Rustにおいてはそれがatomic typesとそれに用意されたmethods。<h4 id=memory-ordering><a aria-label="Anchor link for: memory-ordering" class=zola-anchor href=#memory-ordering>Memory Ordering</a></h4><p>multithreadの文脈では、あるメモリの値を決めるのに時間(wall-clock)を考慮しない。有効なのはprogrammerが課した制約だけ。なので、thread間では後から書いた値が先に反映されるということがありえる。 どうも自分は<code>Acquire/Release</code>がわかりませんでした。(<code>Release</code>でstoreして、<code>Acquire</code>でloadしておけば変な並び替えおきない程度の理解)このあたりの話題は並行プログラミング入門で再挑戦したいと思います。<h4 id=compare-and-exchange><a aria-label="Anchor link for: compare-and-exchange" class=zola-anchor href=#compare-and-exchange>Compare and Exchange</a></h4><p>compare_exchangeの引数や使い方の説明が非常にわかりやすかった。<br> compare_exchange_weakの説明もあり。<h4 id=the-fetch-methods><a aria-label="Anchor link for: the-fetch-methods" class=zola-anchor href=#the-fetch-methods>The Fetch methods</a></h4><p>複数のthreadが同一のatomic typeの書き換えをcompare_and_swapで行うと、片方は成功し、他方はretryを繰り返すことになる。現在の値によらずに実現したいoperationだけをCPUに伝えるために、<code>fetch_add</code>等のmethodがある。<h3 id=sane-concurrency><a aria-label="Anchor link for: sane-concurrency" class=zola-anchor href=#sane-concurrency>Sane Concurrency</a></h3><p>multithreadだと実行pathが膨大になり、各実行pathをtestするのが難しい。<br> そんなときのために、loom crateがある。<br> 概要としては、closureの形でtest caseを記述するとloomがcross-thread interactionsをtrackして、すべてのinteractionのパターンを試してくれる。<br> 一体どうやったらこんなことが可能なのか完全に謎ですが、機会があれば使ってみようと思いました。<br> 他にもGoogleのThreadSanitizer(TSan)も紹介されていました。<h2 id=foreign-function-interfaces><a aria-label="Anchor link for: foreign-function-interfaces" class=zola-anchor href=#foreign-function-interfaces>Foreign Function Interfaces</a></h2><p>FFIはまったくわかっていないのですがこの章を読んで雰囲気がつかめました。 また、FFIは必ずしも違う言語間に限ったことでなく、Rustで書かれたlibとdynamic linkしていたらそれもFFIといえる。<h3 id=crossing-boundaries-with-extern><a aria-label="Anchor link for: crossing-boundaries-with-extern" class=zola-anchor href=#crossing-boundaries-with-extern>Crossing Boundaries with extern</a></h3><p>FFIは究極的にはapplicationの外のbytesにアクセスすること。<br> Rustはsymbolsとcalling conventionsという２つのbuilding blocksを提供してくれている。 dynamic linkとstatic linkの違いの説明がわかりやすかったです。 FFI boundaryを超えると型が消えるのでその型がどういうbyte列になるかを意識しておく必要がある。 そのために<code>std::os::raw</code>や<code>std::ffi</code>、<code>#[repr(C)]</code>が用意されている。<h3 id=allocation><a aria-label="Anchor link for: allocation" class=zola-anchor href=#allocation>Allocation</a></h3><p>FFIのinterfaceとしては呼び出し側がallocateするか、API側がallocationとfree用のAPIを用意しておくかに大別される。<h3 id=safety><a aria-label="Anchor link for: safety" class=zola-anchor href=#safety>Safety</a></h3><p>thread safeではない外部の型をwrapする際に<code>PhantomData&lt;*const ()></code>型を利用しておくことで、呼び出し側にsingle threadでの扱いを強制させたりする等、FFIをRustの型でwrapして安全なAPIを提供する方法について。<h2 id=rust-without-the-standard-library><a aria-label="Anchor link for: rust-without-the-standard-library" class=zola-anchor href=#rust-without-the-standard-library>Rust Without The Standard Library</a></h2><p>ここでいうsystem programmingはosに頼らず直接hardwareで起動するという意味。<p>std libは実際には<code>core</code>と<code>alloc</code>をre-exportしたものという話。 <code>#![no_std</code>とするとpreludeが書き換わる仕組みらしい。<h3 id=the-rust-runtime><a aria-label="Anchor link for: the-rust-runtime" class=zola-anchor href=#the-rust-runtime>The Rust Runtime</a></h3><p>Rustはruntimeをもっていないといわれるが、mainの前に走るコードと、panicをハンドリングする処理が備わっているという意味でruntimeをもつ。<p>普段panicしたときの挙動はリッチなruntimeだからできていたことなんだと知りました。Writing Os in Rustで出てきた<code>#[panic_handler]</code>や<code>#![no_main]</code>がどうして必要かがすこしわかりうれしかったです。<h3 id=low-level-memory-access><a aria-label="Anchor link for: low-level-memory-access" class=zola-anchor href=#low-level-memory-access>Low Level Memory Access</a></h3><p>memory mapped hardwareを扱うさいに特定のCPU命令がelideされたりreorderされたりしないように<code>std::ptr::{read,write}_volatile</code>が用意されている。<p>registerが特定の状態に遷移することを型で表現する例がわかりやすかったです。<h2 id=the-rust-ecosystem><a aria-label="Anchor link for: the-rust-ecosystem" class=zola-anchor href=#the-rust-ecosystem>The Rust Ecosystem</a></h2><p><code>cargo-{deny,expand,hack,llvm-lines,..}</code>等知らないtoolがたくさん紹介されていました。CIに組み込んでみたいものも多く非常に参考になりました。 ついでに、<code>fd</code>と<code>ripgrep</code>も紹介されていました。<p>その他、著者オススメの日常的によく利用するcrateが紹介されています。<br> 知らないcrateも多くあり、是非調べてりようしてみたいです。(<code>flume</code>のmulti-producer multi-consumer channelとか) 個人的には<code>itertool</code>と<code>tower</code>を使いこなしたいです。<p><code>rustup</code>,<code>cargo</code>,<code>rustc</code>の便利機能も知らないものばかりで参考になりました。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> EntityIdentifier</span><span style=color:#eceff4>&lt;'</span><span style=color:#8fbcbb>a</span><span style=color:#eceff4>> {</span></span>
<span class=giallo-l><span>    namespace</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> Cow</span><span style=color:#eceff4>&lt;'</span><span style=color:#8fbcbb>a</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> str</span><span style=color:#eceff4>>,</span></span>
<span class=giallo-l><span>    name</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> Cow</span><span style=color:#eceff4>&lt;'</span><span style=color:#8fbcbb>a</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb>str</span><span style=color:#eceff4>>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>entityの識別子を上のように宣言しておくことで、検索処理の結果の場合にはOwnedを利用して、取得時の引数としてはBorrowedを利用できるようCowを使うことで、呼び出し側にallocationを強制しない使い方が参考になりました。<p>neat methodsも紹介されています。<br> <code>Clone::clone_from</code>は使えるところではつかってみたいです。<br> <code>Vec::swap_remove</code>もorder変わること許容できるならつかっていきたいです。<h3 id=patterns-in-the-wild><a aria-label="Anchor link for: patterns-in-the-wild" class=zola-anchor href=#patterns-in-the-wild>Patterns in the Wild</a></h3><p>Rustでよく使われる実装patternが紹介されています。<br> panic起きてもちゃんと動くようなcodeというところの問題意識が鍵な気がしました。<h3 id=staying-up-to-date><a aria-label="Anchor link for: staying-up-to-date" class=zola-anchor href=#staying-up-to-date>Staying Up to Date</a></h3><p>Rustの開発状況をおさえておくのにオススメの情報源が紹介されています。 自分は紹介されている<a href=https://this-week-in-rust.org/ rel=external>This Week in Rust</a>をみていました。<h3 id=what-next><a aria-label="Anchor link for: what-next" class=zola-anchor href=#what-next>What Next?</a></h3><p>いろいろなRustの学び方が紹介されています。<br> 文法解説した本とlibraryとして公開されているコードの間を埋めるのがムズいです。。<p>いろいろなリソースが紹介されているので、必ず参考になるものがみつかるのではないでしょうか。自分は<a href=https://rust-unofficial.github.io/too-many-lists/fourth-building.html rel=external>Too Many Lists</a>を読んでみようと思いました。<p><a href=https://fasterthanli.me/tags/rust rel=external>Amos先生のブログ</a>も紹介されておりうれしかったです。<p>dtolnay先生のquizは知りませんでした。</div></article></main><footer class=blog-footer><p>© 2026 <a href=https://blog.ymgyt.io> ymgyt </a> | Made with <a href=https://www.getzola.org rel=noopener target=_blank>Zola</a> | <a href=https://github.com/ymgyt/blog>Repository</a> | <a href=https://blog.ymgyt.io/atom.xml target=_blank title=rss> <svg viewbox="0 0 24 24" class=icon fill=none height=24 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx=5 cy=19 r=1></circle></svg> </a></footer></div></div>