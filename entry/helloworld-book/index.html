<!doctype html><html lang=ja><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=https://blog.ymgyt.io/favicon.ico rel=icon sizes=any><link href=https://blog.ymgyt.io/icon.svg rel=icon type=image/svg+xml><link href=https://blog.ymgyt.io/apple-touch-icon.png rel=apple-touch-icon><link href=https://blog.ymgyt.io/manifest.webmanifest rel=manifest><link href=https://blog.ymgyt.io/style.css rel=stylesheet><link href=https://blog.ymgyt.io/atom.xml rel=alternate title=Atom type=application/atom+xml><script src="https://www.googletagmanager.com/gtag/js?id=G-GTB0KMLN90" async></script><script>window.dataLayer = window.dataLayer || [];
	function gtag() {dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-GTB0KMLN90');</script><title>📕 ハロー"Hello, World" OSと標準ライブラリのシゴトとしくみを読んだ感想 | Happy developing</title><meta content='ハロー"Hello, World"OSと標準ライブラリのシゴトとしくみを読んだ感想について' name=description><meta content=summary name=twitter:card><meta content="@YAmaguchixt " name=twitter:site><meta content='📕 ハロー"Hello, World" OSと標準ライブラリのシゴトとしくみを読んだ感想' name=twitter:title><meta content='ハロー"Hello, World"OSと標準ライブラリのシゴトとしくみを読んだ感想について' name=twitter:description><meta content=https://blog.ymgyt.io/images/emoji/closed_book.png name=twitter:image><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><body><div class=world><div class=content-container><header class=blog-header-container><div class=blog-logo><a href=https://blog.ymgyt.io>Happy developing</a></div><div class=blog-nav><nav><ul><li><a href=https://blog.ymgyt.io/entry/>Entries</a><li><a href=https://blog.ymgyt.io/tags/>Tags</a><li><a href=https://blog.ymgyt.io/about/>About</a><li><a href=https://github.com/ymgyt> <img alt=Github class=icon src=https://blog.ymgyt.io/images/icon/github.svg> </a><li><a href="https://twitter.com/YAmaguchixt "> <img alt=Twitter class=icon src=https://blog.ymgyt.io/images/icon/twitter.svg> </a></ul></nav></div></header><main class=blog-main><article><header class=entry-header><h1 class=entry-title>📕 ハロー"Hello, World" OSと標準ライブラリのシゴトとしくみを読んだ感想</h1><div class=entry-meta><p class=entry-meta-item>🗓 2023-02-21<p class=entry-meta-item>🏷 <span class=tag><a href=https://blog.ymgyt.io/tags/book/>book</a></span></div></header><aside class=entry-toc><nav><ul class=entry-toc-toplevel-list><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#du-ndaben>読んだ本</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-1zhang-haro-warudonihong-retemiru>第1章 ハロー・ワールドに触れてみる</a> <ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#hello-c>hello.c</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#ni-asenburu>逆アセンブル</a></ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-2zhang-printf-nonei-bu-dong-zuo-wozhui-u>第2章 printf()の内部動作を追う</a> <ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#ptrace>ptrace()</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#bainariedeita>バイナリエディタ</a></ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-3zhang-linuxkanerunochu-li-wotan-ru>第3章 Linuxカーネルの処理を探る</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-4zhang-raiburarikaranosisutemukoruhu-bichu-si>第4章 ライブラリからのシステムコール呼び出し</a> <ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#sisutemukorunoabi>システムコールのABI</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#glibcwobirudo>glibcをビルド</a></ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-5zhang-main-guan-shu-noqian-tohou>第5章 main()関数の前と後</a> <ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#sutatoatupunososukodo>スタートアップのソースコード</a></ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-6zhang-biao-zhun-ru-chu-li-guan-shu-noshi-zhuang-womiru>第6章 標準入出力関数の実装をみる</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-7zhang-konpairunoshou-shun-toshi-zu-mi>第7章 コンパイルの手順と仕組み</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-8zhang-shi-xing-huairujie-xi>第8章 実行ファイル解析</a> <ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#elfhuomatuto>ELFフォーマット</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#gong-you-raiburari>共有ライブラリ</a></ul><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-9zhang-zui-shi-hua>第9章 最適化</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-10zhang-yang-nahuan-jing-toyang-naakitekutiya>第10章 様々な環境と様々なアーキテクチャ</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-11zhang-ke-bian-chang-yin-shu-noxi-i>第11章 可変長引数の扱い</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#di-12zhang-jie-shuo-noji-da-cheng-sisutemukorunoqie-riti-ewojian-ru>第12章 解説の集大成 - システムコールの切り替えを見る</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#matome>まとめ</a><li><a href=https://blog.ymgyt.io/entry/helloworld-book/#can-kao>参考</a></ul></nav></aside><div class=entry-content><h2 id=du-ndaben><a aria-label="Anchor link for: du-ndaben" class=zola-anchor href=#du-ndaben>読んだ本</a></h2><figure><div class=fig-images-row><img , alt src=images/helloworld-book.png></div></figure><p><a href=http://kozos.jp/books/helloworld/ rel=external>ハロー“Hello, World” OSと標準ライブラリのシゴトとしくみ</a><br> 著者: <a href=http://kozos.jp/index.html rel=external>坂井弘亮</a><p>main()の前にはなにがあるのかという見出しが気になって読んでみたので感想を書きます。<br> 環境再現用のVM imageが提供されているので、筆者が行っている調査を手元で実際に確かめられながら進められます。<p>(2024年11月26日に <a href=https://www.shuwasystem.co.jp/book/9784798074146.html rel=external>第2版</a> が発売されました 🎉)<h2 id=di-1zhang-haro-warudonihong-retemiru><a aria-label="Anchor link for: di-1zhang-haro-warudonihong-retemiru" class=zola-anchor href=#di-1zhang-haro-warudonihong-retemiru>第1章 ハロー・ワールドに触れてみる</a></h2><p>環境を準備して、main()のアセンブラを読んでみるまでを行います。<br> 自分は、VirtualBoxをMacBookPro11,4 Intel Core i7上で動かしました。<br> 実作業はVMにportforwardを設定し、手元のterminalからsshして行いました。 VMの設定の仕方についても画像付きで説明があるのでわかりやすかったです。<br> 提供されているVMを利用すると必要なfileやtoolが全て揃っているので、環境構築でつまづくことはないと思います。<p>ということで早速進めていきます。<h3 id=hello-c><a aria-label="Anchor link for: hello-c" class=zola-anchor href=#hello-c><code>hello.c</code></a></h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=c><span class=giallo-l><span style=color:#5e81ac;font-weight:700>#</span><span style=color:#81a1c1>include</span><span style=color:#eceff4> &lt;</span><span style=color:#8fbcbb>stdio.h</span><span style=color:#eceff4>></span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>int</span><span style=color:#88c0d0> main</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>int</span><span> argc</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> char *</span><span>argv</span><span style=color:#81a1c1>[]</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#eceff4>{</span></span>
<span class=giallo-l><span style=color:#88c0d0>  printf</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>Hello World! %d %s</span><span style=color:#ebcb8b>\n</span><span style=color:#eceff4>",</span><span> argc</span><span style=color:#eceff4>,</span><span> argv</span><span style=color:#eceff4>[</span><span style=color:#b48ead>0</span><span style=color:#eceff4>])</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>  return</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>本書で扱うプログラムです。実行すると引数の数と実行binaryのpathを出力します。<h3 id=ni-asenburu><a aria-label="Anchor link for: ni-asenburu" class=zola-anchor href=#ni-asenburu>逆アセンブル</a></h3><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span># objdump -d hello -M att | grep -A 25 '&lt;main>'</span></span>
<span class=giallo-l><span>080482bc &lt;main>:</span></span>
<span class=giallo-l><span> 80482bc:       55                      push   %ebp                 ; 1</span></span>
<span class=giallo-l><span> 80482bd:       89 e5                   mov    %esp,%ebp            ; 2</span></span>
<span class=giallo-l><span> 80482bf:       83 e4 f0                and    $0xfffffff0,%esp     ; 3</span></span>
<span class=giallo-l><span> 80482c2:       83 ec 10                sub    $0x10,%esp           ; 4</span></span>
<span class=giallo-l><span> 80482c5:       8b 45 0c                mov    0xc(%ebp),%eax       ; 5</span></span>
<span class=giallo-l><span> 80482c8:       8b 10                   mov    (%eax),%edx          ; 6</span></span>
<span class=giallo-l><span> 80482ca:       b8 0c 36 0b 08          mov    $0x80b360c,%eax      ; 7</span></span>
<span class=giallo-l><span> 80482cf:       89 54 24 08             mov    %edx,0x8(%esp)       ; 8</span></span>
<span class=giallo-l><span> 80482d3:       8b 55 08                mov    0x8(%ebp),%edx       ; 9</span></span>
<span class=giallo-l><span> 80482d6:       89 54 24 04             mov    %edx,0x4(%esp)       ; 10</span></span>
<span class=giallo-l><span> 80482da:       89 04 24                mov    %eax,(%esp)          ; 11</span></span>
<span class=giallo-l><span> 80482dd:       e8 7e 10 00 00          call   8049360 &lt;_IO_printf> ; 12</span></span>
<span class=giallo-l><span> 80482e2:       b8 00 00 00 00          mov    $0x0,%eax            ; 13</span></span>
<span class=giallo-l><span> 80482e7:       c9                      leave                       ; 14</span></span>
<span class=giallo-l><span> 80482e8:       c3                      ret                         ; 15</span></span>
<span class=giallo-l><span> 80482e9:       90                      nop</span></span>
<span class=giallo-l><span> 80482ea:       90                      nop</span></span>
<span class=giallo-l><span> 80482eb:       90                      nop</span></span>
<span class=giallo-l><span> 80482ec:       90                      nop</span></span>
<span class=giallo-l><span> 80482ed:       90                      nop</span></span>
<span class=giallo-l><span> 80482ee:       90                      nop</span></span>
<span class=giallo-l><span> 80482ef:       90                      nop</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>080482f0 &lt;__libc_start_main>:</span></span>
<span class=giallo-l><span> 80482f0:       55                      push   %ebp</span></span></code></pre><p><code>objdump</code>でdisassembleします。 <code>-M att</code>をつけなくても同じ結果になるのですが、Intel記法とAT&Tでいつも混乱するので明示的につけるようにしています。(末尾にコメントを付与しました)<br> AT&T記法では、第一引数がsourceで第二引数がdestなので逆のIntel記法より直感的だと思います。<code>%</code>がでてきたらAT&Tと覚える様にしています。<p>このアセンブリを読んでみる上での前提知識<ul><li>x86のstackはzeroに向かって伸びるので、stack frameを確保するにはstack pointerをsubする<li>push命令はstack pointerを4byte(32bitCPU)減算して、引数の値を書き込む<li>関数からの戻り値はeax registerで返す</ul><p>これらを念頭に上から読んでいくと<ol><li>現在のbase pointerをstackに退避<li>現在のstack pointerをbase pointerとして保持<li>stack pointerを16byteにalign<li>stack frameを16byte確保<li>mainの第2引数(<code>argv</code>)をeaxに保存<li>eaxを参照(<code>argv[0]</code>)してedxに保存<li>0x80b360cをeaxに保存<li>6で保存した<code>argv[0]</code>の値をedxからprintfの第3引数に保存<li>mainの第1引数(<code>argc</code>)をedxに保存<li><code>argc</code>の値をedxからprintfの第2引数に保存<li>7でeaxに保持していた0x80b360cをprintfの第1引数に保存<li>printf呼び出し<li>戻り値0をeaxに保存<li>この時点では説明がなかったですがleaveは<code>mov %ebp %esp</code>, <code>pop %ebp</code>を行うらしいので, stack frameをmain呼び出し前の状態に戻し、1で保持していたebpの値を復元。<li>呼び出し元に戻る</ol><p>という風に理解しました。<br> x86において関数の引数はstack経由で渡され,stack pointerは戻り先アドレスを指している状態になっており、+4のの位置には第1引数、+8の位置には第2引数が格納されているということらしいです。<br> ただし、1のpushでebpが4byte減算されるので、c(+12)byteに第2引数があります。<p>ということで雰囲気ではありますが、関数呼び出し規約に基づいてstack pointerの相対位置から渡された引数をprintfに渡していることがなんとなくわかりました。<br> ちなみに最後の<code>nop</code>の連続は次の関数のalignするために埋められているもので、<code>__libc_start_main</code>が80482f0(下位4bitが0)のように16byte alignmentになっています。<p>最近読んだ、CPU関連の本(CPUの気持ち本、Rust atomics and locks, プロセッサを支える技術) のおかげでcache lineのためにalignmentしたいという問題意識がなんとなくわかったのがうれしいです。<h2 id=di-2zhang-printf-nonei-bu-dong-zuo-wozhui-u><a aria-label="Anchor link for: di-2zhang-printf-nonei-bu-dong-zuo-wozhui-u" class=zola-anchor href=#di-2zhang-printf-nonei-bu-dong-zuo-wozhui-u>第2章 printf()の内部動作を追う</a></h2><p>次はいよいよprintf()の内部を見ていきます。<br> 具体的にはgdbを使って、printf()の中で"Hello world!"を出力する命令の特定を試みます。<br> gdbの使い方について丁寧に教えてくれます。<br> 結構地道な作業でnextiという次の命令を実行するコマンドを数十回繰り返したりします。<p>最終的に<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>0x8055a80 &lt;_dl_sysinfo_int80>   int    $0x80                                                                               │</span></span>
<span class=giallo-l><span>0x8055a82 &lt;_dl_sysinfo_int80+2> ret  </span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>(gdb) where</span></span>
<span class=giallo-l><span>#0  0x08055a82 in _dl_sysinfo_int80 ()</span></span>
<span class=giallo-l><span>#1  0x08053d92 in __write_nocancel ()</span></span>
<span class=giallo-l><span>#2  0x08067671 in _IO_new_file_write ()</span></span>
<span class=giallo-l><span>#3  0x0806819b in _IO_new_do_write ()</span></span>
<span class=giallo-l><span>#4  0x080683ea in _IO_new_file_overflow ()</span></span>
<span class=giallo-l><span>#5  0x080673f4 in _IO_new_file_xsputn ()</span></span>
<span class=giallo-l><span>#6  0x08059738 in vfprintf ()</span></span>
<span class=giallo-l><span>#7  0x08049381 in printf ()</span></span>
<span class=giallo-l><span>#8  0x080482e2 in main (argc=1, argv=0xbffff634) at hello.c:5</span></span></code></pre><p>というint命令(システムコール)にたどり着きます。このint命令を実行すると"Hello world!"が出力されました。<br> 概念としては標準libの中でsystemcallが呼ばれるとわかっていましたが、実際にみてみるとうれしいですね。<br> VMの再現のおかげで本とアドレスが完全に一致しているのも親切でした。<h3 id=ptrace><a aria-label="Anchor link for: ptrace" class=zola-anchor href=#ptrace>ptrace()</a></h3><p>ptrace()というシステムコールを用いて独自のtrace処理を行います。<br> man ptraceで<code>/usr/include/sys/user.h</code>参照と書いてあるが実際には説明がないのでそんな時は、Linuxカーネルのソースコートを見るのが手っ取り早いとあって、そうなるのがすごいなと思いました。<h3 id=bainariedeita><a aria-label="Anchor link for: bainariedeita" class=zola-anchor href=#bainariedeita>バイナリエディタ</a></h3><figure><div class=fig-images-row><img , alt src=images/edit_helloworld.png></div><figcaption>nop(0x90)でシステムコール命令を書き換える</figcaption></figure><p>バイナリエディタのhexeditを使って、システムコールの命令を<code>nop</code>(0x90)に書き換えてみます。<br> 実際にやってみたところ、本当に"Hello world!"が出力されませんでした。<h2 id=di-3zhang-linuxkanerunochu-li-wotan-ru><a aria-label="Anchor link for: di-3zhang-linuxkanerunochu-li-wotan-ru" class=zola-anchor href=#di-3zhang-linuxkanerunochu-li-wotan-ru>第3章 Linuxカーネルの処理を探る</a></h2><p>"Hello world!"を出力したシステムコールが実行されたときに何が起きるかをLinuxカーネル側から見ていきます。<br> ここは追うのが難しかったです。<p>システムコール実行直前のregisterの中身を確認して、eax registerに4が格納されていることを確認したのち、その値がカーネル側の割り込みハンドラで参照されていることを確認します。<br> ただし、C言語からはeaxに値を格納するというような処理は(アセンブラを使わなければ)書けないので、システムコールラッパーが処理を仲介していると続きます。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>objdump</span><span style=color:#a3be8c> -d hello</span><span style=color:#81a1c1> |</span><span style=color:#88c0d0> grep</span><span style=color:#a3be8c> -A</span><span style=color:#b48ead> 10</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>08053d7a &lt;__write_nocancel></span><span style=color:#eceff4>'</span></span>
<span class=giallo-l><span style=color:#88c0d0>08053d7a</span><span style=color:#81a1c1> &lt;</span><span style=color:#a3be8c>__write_nocance</span><span>l</span><span style=color:#81a1c1>></span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l><span style=color:#88c0d0>8053d7a:</span><span style=color:#b48ead>       53</span><span style=color:#a3be8c>                      push   %ebx</span></span>
<span class=giallo-l><span style=color:#88c0d0>8053d7b:</span><span style=color:#a3be8c>       8b</span><span style=color:#b48ead> 54 24 10</span><span style=color:#a3be8c>             mov</span><span style=color:#b48ead>    0x10</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>%esp</span><span style=color:#eceff4>)</span><span style=color:#a3be8c>,%edx</span></span>
<span class=giallo-l><span style=color:#88c0d0>8053d7f:</span><span style=color:#a3be8c>       8b 4c</span><span style=color:#b48ead> 24</span><span style=color:#a3be8c> 0c             mov</span><span style=color:#b48ead>    0xc</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>%esp</span><span style=color:#eceff4>)</span><span style=color:#a3be8c>,%ecx</span></span>
<span class=giallo-l><span style=color:#88c0d0>8053d83:</span><span style=color:#a3be8c>       8b 5c</span><span style=color:#b48ead> 24 08</span><span style=color:#a3be8c>             mov</span><span style=color:#b48ead>    0x8</span><span style=color:#eceff4>(</span><span style=color:#88c0d0>%esp</span><span style=color:#eceff4>)</span><span style=color:#a3be8c>,%ebx</span></span>
<span class=giallo-l><span style=color:#88c0d0>8053d87:</span><span style=color:#a3be8c>       b8</span><span style=color:#b48ead> 04 00 00 00</span><span style=color:#a3be8c>          mov</span><span>    $0x4</span><span style=color:#a3be8c>,%eax</span><span style=color:#81a1c1> ;</span><span style=color:#88c0d0>  👈</span></span>
<span class=giallo-l><span style=color:#88c0d0>8053d8c:</span><span style=color:#a3be8c>       ff</span><span style=color:#b48ead> 15 50 67</span><span style=color:#a3be8c> 0d</span><span style=color:#b48ead> 08</span><span style=color:#a3be8c>       call</span><span style=color:#81a1c1>   *</span><span style=color:#a3be8c>0x80d6750</span><span>  </span></span></code></pre><p>実際にアセンブリでeaxに4が保存されており、その後にcallされている<code>*0x80d6750</code>が下記のようにシステムコールであると確かめられます。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>(gdb) disassemble *0x80d6750</span></span>
<span class=giallo-l><span>Dump of assembler code for function _dl_sysinfo_int80:</span></span>
<span class=giallo-l><span>   0x08055a80 &lt;+0>:     int    $0x80</span></span>
<span class=giallo-l><span>   0x08055a82 &lt;+2>:     ret</span></span></code></pre><p>また、システムコールの戻り値や上限を超える引数についてもシステムコールラッパーが間に入り、C言語に統一的なAPIを提供している例が説明されます。<p>ちなみに、<code>linux-2.6.32.65/arch/x86/kernel/entry_32.S</code>に<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>/*</span></span>
<span class=giallo-l><span> *</span></span>
<span class=giallo-l><span> *  Copyright (C) 1991, 1992  Linus Torvalds</span></span>
<span class=giallo-l><span> */</span></span></code></pre><p>が出てきて嬉しくなりました。<h2 id=di-4zhang-raiburarikaranosisutemukoruhu-bichu-si><a aria-label="Anchor link for: di-4zhang-raiburarikaranosisutemukoruhu-bichu-si" class=zola-anchor href=#di-4zhang-raiburarikaranosisutemukoruhu-bichu-si>第4章 ライブラリからのシステムコール呼び出し</a></h2><p>printf()がC言語から呼べれるのは標準ライブラリCがあるからで、CentOSではそれは、GNUプロジェクトによるGNU C Library(glibc)によって提供されている。<br> そこで本章ではglibcのソースからprintf()の中で呼ばれていたシステムコールラッパーの実装を見ていきます。<p>ただ、glibcでは実際にint命令を発行するソースはマクロとテンプレートで実装されており、追うのが難しかったです。<h3 id=sisutemukorunoabi><a aria-label="Anchor link for: sisutemukorunoabi" class=zola-anchor href=#sisutemukorunoabi>システムコールのABI</a></h3><p>Linux/x86でシステムコールを呼ぶには、registerに引数をセットして、int $0x80を実行していた。<br> これはLinuxにおけるx86の仕様で、CPUアーキテクチャが異なればまた変わってくる。(そもそもregisterが違う)<br> また、FreeBSD等カーネルが違えばまた変わってくる。<p>しかし、アプリケーション側で実行環境のカーネルやCPUを意識するのは大変なのでシステムコールを呼び出すアセンブラ処理を用意し、アプリケーションからはそれを呼ぶ様にする。<p>実際に以下のようなアセンブリを用意して、C言語から呼び出せた。<p><code>write.S</code><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>.global _write</span></span>
<span class=giallo-l><span>_write:</span></span>
<span class=giallo-l><span>	push %ebx</span></span>
<span class=giallo-l><span>	mov $4, %eax</span></span>
<span class=giallo-l><span>	mov 8(%esp), %ebx</span></span>
<span class=giallo-l><span>	mov 12(%esp), %ecx</span></span>
<span class=giallo-l><span>	mov 16(%esp), %edx</span></span>
<span class=giallo-l><span>	int $0x80</span></span>
<span class=giallo-l><span>	pop %ebx</span></span>
<span class=giallo-l><span>	ret</span></span></code></pre><p><code>main.c</code><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=c><span class=giallo-l><span style=color:#81a1c1>int</span><span style=color:#88c0d0> main</span><span style=color:#eceff4>() {</span></span>
<span class=giallo-l><span style=color:#88c0d0>  _write</span><span style=color:#eceff4>(</span><span style=color:#b48ead>1</span><span style=color:#eceff4>, "</span><span style=color:#a3be8c>Hello World!</span><span style=color:#ebcb8b>\n</span><span style=color:#eceff4>",</span><span style=color:#b48ead> 13</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>  return</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>gcc main.c write.S -o _write</span></span>
<span class=giallo-l><span>./_write</span></span>
<span class=giallo-l><span>Hello World!</span></span></code></pre><p><strong>Linux/x86では引数はregister経由で渡すというシステムコール時のルールという意味でのABIと、x86では関数呼び出し時に引数をスタックで渡すという意味でのABIでは指しているものが違う</strong>という説明が非常にわかりやすかったです。<br> ABIについていまいちピンときていなかったのですが本書を読んでちょっとしっくりくるようになったのが嬉しいです。<p>また、システムコールラッパーを呼ぶ際の引数のsignatureこそが、POSIXで定められたAPIでこのAPIのレイヤーでLinux/ARMやFreeBSD/i386といったABIの差が吸収されているという説明も非常にわかりやすかったです。<h3 id=glibcwobirudo><a aria-label="Anchor link for: glibcwobirudo" class=zola-anchor href=#glibcwobirudo>glibcをビルド</a></h3><p>システムコールラッパーを提供してくれているglibcをソースコードからビルドしていきます。<br> <code>./configure</code>, <code>make</code>, <code>make install</code>としていくのですが、<code>configure</code>や<code>make</code>で普通にエラーになります。<br> そのエラーをコメントアウトしながら修正していくのですが、自分一人なら絶対できないだろうなと思います。<p>buildしたglibcを<code>/usr/local</code>配下にinstallしたのちに、helloとリンクします。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>gcc hello.c -o hello -Wall -O0 -static /usr/local/glibc-2.21/lib/libc.a  </span></span></code></pre><p>こうすると, helloをgdbでdebugした際に、printf()の中でもソースコードがみれるようになりました。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>(gdb) where</span></span>
<span class=giallo-l><span>#0  write () at ../sysdeps/unix/syscall-template.S:81</span></span>
<span class=giallo-l><span>#1  0x08050f08 in _IO_new_file_write (f=0x80df1e0, data=&lt;value optimized out>, n=44) at fileops.c:1251</span></span>
<span class=giallo-l><span>#2  0x08050bcc in new_do_write (fp=0x80df1e0, data=0xb7fff000 "Hello World! 1 /home/user/build/hello/hello\n", to_do=&lt;value optimized out>)</span></span>
<span class=giallo-l><span>    at fileops.c:506</span></span>
<span class=giallo-l><span>#3  0x08050e95 in _IO_new_do_write (fp=0x80df1e0, data=0xb7fff000 "Hello World! 1 /home/user/build/hello/hello\n", to_do=44) at fileops.c:482</span></span>
<span class=giallo-l><span>#4  0x08051a3d in _IO_new_file_overflow (f=0x80df1e0, ch=-1) at fileops.c:839</span></span>
<span class=giallo-l><span>#5  0x08050d07 in _IO_new_file_xsputn (f=0x80df1e0, data=0x80be37e, n=1) at fileops.c:1319</span></span>
<span class=giallo-l><span>#6  0x0807ce8d in _IO_vfprintf_internal (s=0x80df1e0, format=&lt;value optimized out>,</span></span>
<span class=giallo-l><span>    ap=0xbffff56c "\210\201\004\b\030\361\r\b\210\201\004\b\350\365\377\277v\205\004\b\001") at vfprintf.c:1673</span></span>
<span class=giallo-l><span>#7  0x0804deb1 in __printf (format=0x80be36c "Hello World! %d %s\n") at printf.c:33</span></span>
<span class=giallo-l><span>#8  0x080483c2 in main (argc=1, argv=0xbffff614) at hello.c:5</span></span></code></pre><p>スタックトレースにもソースコードのfileが表示されました。<h2 id=di-5zhang-main-guan-shu-noqian-tohou><a aria-label="Anchor link for: di-5zhang-main-guan-shu-noqian-tohou" class=zola-anchor href=#di-5zhang-main-guan-shu-noqian-tohou>第5章 main()関数の前と後</a></h2><p>まず, gdbでmain()で実行している<code>return 0;</code>の次の命令をnextで確認すると、<code>__libc_start_main()</code>であることがわかります。さらにbreakpointを貼ってみると、<code>_start()</code>から呼ばれていることがわかりました。 ここで、<code>_start()</code>がプログラムの開始処理であるとするとその情報はELFに格納されているはず、ということでELFをみてみると、<code>Entry point address: 0x80481c0</code>とあります。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>readelf -a hello | head -n 20</span></span>
<span class=giallo-l><span>ELF Header:</span></span>
<span class=giallo-l><span>  Magic:   7f 45 4c 46 01 01 01 03 00 00 00 00 00 00 00 00</span></span>
<span class=giallo-l><span>  Class:                             ELF32</span></span>
<span class=giallo-l><span>  Data:                              2's complement, little endian</span></span>
<span class=giallo-l><span>  Version:                           1 (current)</span></span>
<span class=giallo-l><span>  OS/ABI:                            UNIX - Linux</span></span>
<span class=giallo-l><span>  ABI Version:                       0</span></span>
<span class=giallo-l><span>  Type:                              EXEC (Executable file)</span></span>
<span class=giallo-l><span>  Machine:                           Intel 80386</span></span>
<span class=giallo-l><span>  Version:                           0x1</span></span>
<span class=giallo-l><span>  Entry point address:               0x80481c0  👈</span></span>
<span class=giallo-l><span>  Start of program headers:          52 (bytes into file)</span></span>
<span class=giallo-l><span>  Start of section headers:          582884 (bytes into file)</span></span>
<span class=giallo-l><span>  Flags:                             0x0</span></span>
<span class=giallo-l><span>  Size of this header:               52 (bytes)</span></span>
<span class=giallo-l><span>  Size of program headers:           32 (bytes)</span></span>
<span class=giallo-l><span>  Number of program headers:         5</span></span>
<span class=giallo-l><span>  Size of section headers:           40 (bytes)</span></span>
<span class=giallo-l><span>  Number of section headers:         41</span></span>
<span class=giallo-l><span>  Section header string table index: 38</span></span></code></pre><p>これはgdbで確認した、<code>_start()</code>のアドレスと一致します。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>(gdb) break _start</span></span>
<span class=giallo-l><span>Breakpoint 1 at 0x80481c0</span></span>
<span class=giallo-l><span>(gdb) run</span></span>
<span class=giallo-l><span>Starting program: /home/user/hello/hello</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>Breakpoint 1, 0x080481c0 in _start ()</span></span>
<span class=giallo-l><span>(gdb) where</span></span>
<span class=giallo-l><span>#0  0x080481c0 in _start ()</span></span></code></pre><p>また、以下のように<code>__libc_start_main()</code>から<code>main()</code>を呼んだ後に、eax registerの値をstackに積んで、exitをcallしているので、main()の戻り値が終了ステータスになることがわかりました。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>0x8048475 &lt;__libc_start_main+389>       call   *0x8(%ebp)    👈 main()</span></span>
<span class=giallo-l><span>0x8048478 &lt;__libc_start_main+392>       mov    %eax,(%esp)</span></span>
<span class=giallo-l><span>0x804847b &lt;__libc_start_main+395>       call   0x8048e60 &lt;exit></span></span></code></pre><h3 id=sutatoatupunososukodo><a aria-label="Anchor link for: sutatoatupunososukodo" class=zola-anchor href=#sutatoatupunososukodo>スタートアップのソースコード</a></h3><p>プログラムは<code>main()</code>から始まるというのは、アプリケーション作成者の観点での話であって、実際は<code>_start()</code>から始まっている。<br> そしてこの処理は標準Cライブラリによって提供されているので、今度はglicで該当のソースを探していきます。<p>glibc配下で、<code>grep -r __libc_start_main .</code>を実行し、<code>sysdeps/i386/start.S</code>に当たりをつけます。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=c><span class=giallo-l><span style=color:#616e88>/* This is the canonical entry point, usually the first thing in the text</span></span>
<span class=giallo-l><span style=color:#616e88>   segment.  The SVR4/i386 ABI (pages 3-31, 3-32) says that when the entry</span></span>
<span class=giallo-l><span style=color:#616e88>   point runs, most registers' values are unspecified, except for:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>   %edx         Contains a function pointer to be registered with `atexit'.</span></span>
<span class=giallo-l><span style=color:#616e88>                This is how the dynamic linker arranges to have DT_FINI</span></span>
<span class=giallo-l><span style=color:#616e88>                functions called for shared libraries that have been loaded</span></span>
<span class=giallo-l><span style=color:#616e88>                before this code runs.</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>   %esp         The stack contains the arguments and environment:</span></span>
<span class=giallo-l><span style=color:#616e88>                0(%esp)                 argc</span></span>
<span class=giallo-l><span style=color:#616e88>                4(%esp)                 argv[0]</span></span>
<span class=giallo-l><span style=color:#616e88>                ...</span></span>
<span class=giallo-l><span style=color:#616e88>                (4*argc)(%esp)          NULL</span></span>
<span class=giallo-l><span style=color:#616e88>                (4*(argc+1))(%esp)      envp[0]</span></span>
<span class=giallo-l><span style=color:#616e88>                ...</span></span>
<span class=giallo-l><span style=color:#616e88>                                        NULL</span></span>
<span class=giallo-l><span style=color:#616e88>*/</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>        .text</span></span>
<span class=giallo-l><span>        .globl _start</span></span>
<span class=giallo-l><span>        .type _start</span><span style=color:#eceff4>,</span><span>@function</span></span>
<span class=giallo-l><span>_start:</span></span>
<span class=giallo-l><span style=color:#616e88>        /* Clear the frame pointer.  The ABI suggests this be done, to mark</span></span>
<span class=giallo-l><span style=color:#616e88>           the outermost frame obviously.  */</span></span>
<span class=giallo-l><span>        xorl </span><span style=color:#81a1c1>%</span><span>ebp</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> %</span><span>ebp</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>        /* Extract the arguments as encoded on the stack and set up</span></span>
<span class=giallo-l><span style=color:#616e88>           the arguments for `main': argc, argv.  envp will be determined</span></span>
<span class=giallo-l><span style=color:#616e88>           later in __libc_start_main.  */</span></span>
<span class=giallo-l><span>        popl </span><span style=color:#81a1c1>%</span><span>esi</span><span style=color:#616e88>               /* Pop the argument count.  */</span></span>
<span class=giallo-l><span>        movl </span><span style=color:#81a1c1>%</span><span>esp</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> %</span><span>ecx</span><span style=color:#616e88>         /* argv starts just at the current stack top.*/</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>        /* Before pushing the arguments align the stack to a 16-byte</span></span>
<span class=giallo-l><span style=color:#616e88>        (SSE needs 16-byte alignment) boundary to avoid penalties from</span></span>
<span class=giallo-l><span style=color:#616e88>        misaligned accesses.  Thanks to Edward Seidl &lt;seidl@janed.com></span></span>
<span class=giallo-l><span style=color:#616e88>        for pointing this out.  */</span></span>
<span class=giallo-l><span>        andl $</span><span style=color:#81a1c1>0x</span><span style=color:#b48ead>fffffff0</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> %</span><span>esp</span></span>
<span class=giallo-l><span>        pushl </span><span style=color:#81a1c1>%</span><span>eax</span><span style=color:#616e88>              /* Push garbage because we allocate</span></span>
<span class=giallo-l><span style=color:#616e88>                                   28 more bytes.  */</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>        /* Provide the highest stack address to the user code (for stacks</span></span>
<span class=giallo-l><span style=color:#616e88>           which grow downwards).  */</span></span>
<span class=giallo-l><span>        pushl </span><span style=color:#81a1c1>%</span><span>esp</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>        pushl </span><span style=color:#81a1c1>%</span><span>edx</span><span style=color:#616e88>              /* Push address of the shared library</span></span>
<span class=giallo-l><span style=color:#616e88>                                   termination function.  */</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#5e81ac;font-weight:700>#ifdef</span><span style=color:#88c0d0> SHARED</span></span>
<span class=giallo-l><span style=color:#616e88>        /* Load PIC register.  */</span></span>
<span class=giallo-l><span>        call </span><span style=color:#b48ead>1</span><span style=color:#81a1c1>f</span></span>
<span class=giallo-l><span>        addl $_GLOBAL_OFFSET_TABLE_</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> %</span><span>ebx</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>        /* Push address of our own entry points to .fini and .init.  */</span></span>
<span class=giallo-l><span>        leal __libc_csu_fini@</span><span style=color:#88c0d0>GOTOFF</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>%</span><span>ebx</span><span style=color:#eceff4>),</span><span style=color:#81a1c1> %</span><span>eax</span></span>
<span class=giallo-l><span>        pushl </span><span style=color:#81a1c1>%</span><span>eax</span></span>
<span class=giallo-l><span>        leal __libc_csu_init@</span><span style=color:#88c0d0>GOTOFF</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>%</span><span>ebx</span><span style=color:#eceff4>),</span><span style=color:#81a1c1> %</span><span>eax</span></span>
<span class=giallo-l><span>        pushl </span><span style=color:#81a1c1>%</span><span>eax</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>        pushl </span><span style=color:#81a1c1>%</span><span>ecx</span><span style=color:#616e88>              /* Push second argument: argv.  */</span></span>
<span class=giallo-l><span>        pushl </span><span style=color:#81a1c1>%</span><span>esi</span><span style=color:#616e88>              /* Push first argument: argc.  */</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>        pushl main@</span><span style=color:#88c0d0>GOT</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>%</span><span>ebx</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>        /* Call the user's main function, and exit with its value.</span></span>
<span class=giallo-l><span style=color:#616e88>           But let the libc call main.    */</span></span>
<span class=giallo-l><span>        call __libc_start_main@PLT</span></span>
<span class=giallo-l><span style=color:#5e81ac;font-weight:700>#else</span></span>
<span class=giallo-l><span style=color:#616e88>        /* Push address of our own entry points to .fini and .init.  */</span></span>
<span class=giallo-l><span>        pushl $__libc_csu_fini</span></span>
<span class=giallo-l><span>        pushl $__libc_csu_init</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>        pushl </span><span style=color:#81a1c1>%</span><span>ecx</span><span style=color:#616e88>              /* Push second argument: argv.  */</span></span>
<span class=giallo-l><span>        pushl </span><span style=color:#81a1c1>%</span><span>esi</span><span style=color:#616e88>              /* Push first argument: argc.  */</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>        pushl $main</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#616e88>        /* Call the user's main function, and exit with its value.</span></span>
<span class=giallo-l><span style=color:#616e88>           But let the libc call main.    */</span></span>
<span class=giallo-l><span>        call __libc_start_main</span></span>
<span class=giallo-l><span style=color:#5e81ac;font-weight:700>#endif</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>        hlt</span><span style=color:#616e88>                     /* Crash if somehow `exit' does return.  */</span></span>
<span class=giallo-l></span></code></pre><p>わからないことのほうが多いのですが、stackになんらかの情報があることを前提に、前処理を行い、<code>__libc_start_main()</code>を実行しています。<br> この時点で、stackを16byte alignしているのもおもしろいです。<br> プログラムってどうやって実行されるんだろうと思っていたので、最初の処理を確認できてうれしいです。<br> 本章では終了処理のexitについても調べていきます。<h2 id=di-6zhang-biao-zhun-ru-chu-li-guan-shu-noshi-zhuang-womiru><a aria-label="Anchor link for: di-6zhang-biao-zhun-ru-chu-li-guan-shu-noshi-zhuang-womiru" class=zola-anchor href=#di-6zhang-biao-zhun-ru-chu-li-guan-shu-noshi-zhuang-womiru>第6章 標準入出力関数の実装をみる</a></h2><p>printf()の実装を読んでいきます。自分のC力が足りないのと、マクロだらけで理解が難しかったです。<br> Rustのmacroは読みやすいんだなと実感させられます。<br> FreeBSDやNewlibの実装も対象です。<br> FreeBSDというのをよく知らなかったのですが、カーネルのソースと標準Cライブラリ、基本コマンドがすべて同一プロジェクトで管理されていて、シンプルでいいなと思ってしまいました。<h2 id=di-7zhang-konpairunoshou-shun-toshi-zu-mi><a aria-label="Anchor link for: di-7zhang-konpairunoshou-shun-toshi-zu-mi" class=zola-anchor href=#di-7zhang-konpairunoshou-shun-toshi-zu-mi>第7章 コンパイルの手順と仕組み</a></h2><p>compileといったときに何が行われているかについて、cc1, as ,collect2といったツールが具体的に使われているのは知りませんでした。<br> OSの定義についても述べられているのですが、汎用なのか、組み込みなのか、UNIXライクなのか等で、実は統一的な定義は難しいんだなと知りました。<br> 筆者が提唱されている万人にしっくりとくる定義はなるほどでした。<p>open()やwrite()等のPOSIXで定められたAPIを提供するのはカーネルではなくシステムコールラッパーなので、UNIXライクとは、POSIXインターフェースを実現するための機能をカーネルが持っているという説明は非常にわかりやすかったです。<br> UNIXライクという言葉の意味はなんとなくしかわかっていなかったので、明確に説明されていて理解が進みました。<p>この章を通して、自分がLinuxだと思っていたものの多くが実はGNUの話だったことがわかりました。<h2 id=di-8zhang-shi-xing-huairujie-xi><a aria-label="Anchor link for: di-8zhang-shi-xing-huairujie-xi" class=zola-anchor href=#di-8zhang-shi-xing-huairujie-xi>第8章 実行ファイル解析</a></h2><p>バイナリーファイルをhexeditで確認して、"Hello world"を"HELLO WORLD"に書き換えてみたりします。<br> バイナリーを見るだけでも、32ビットアーキテクチャであったり、リトルエンディアンであったが推測できるのは意外でした。<h3 id=elfhuomatuto><a aria-label="Anchor link for: elfhuomatuto" class=zola-anchor href=#elfhuomatuto>ELFフォーマット</a></h3><p><code>readelf</code>でELFフォーマットの情報を確認できる。<br> LinuxでELFフォーマットの実行fileを実行すると、カーネルは何らかの方法でELFの構造を知っているはずなので、そのソースを探します。<br> すると, <code>linux-2.6.32.65/include/linux/elf.h</code>に以下のように定義されていました。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>typedef struct elf32_hdr{</span></span>
<span class=giallo-l><span>  unsigned char e_ident[EI_NIDENT];</span></span>
<span class=giallo-l><span>  Elf32_Half    e_type;</span></span>
<span class=giallo-l><span>  Elf32_Half    e_machine;</span></span>
<span class=giallo-l><span>  Elf32_Word    e_version;</span></span>
<span class=giallo-l><span>  Elf32_Addr    e_entry;  /* Entry point */</span></span>
<span class=giallo-l><span>  Elf32_Off     e_phoff;</span></span>
<span class=giallo-l><span>  Elf32_Off     e_shoff;</span></span>
<span class=giallo-l><span>  Elf32_Word    e_flags;</span></span>
<span class=giallo-l><span>  Elf32_Half    e_ehsize;</span></span>
<span class=giallo-l><span>  Elf32_Half    e_phentsize;</span></span>
<span class=giallo-l><span>  Elf32_Half    e_phnum;</span></span>
<span class=giallo-l><span>  Elf32_Half    e_shentsize;</span></span>
<span class=giallo-l><span>  Elf32_Half    e_shnum;</span></span>
<span class=giallo-l><span>  Elf32_Half    e_shstrndx;</span></span>
<span class=giallo-l><span>} Elf32_Ehdr;</span></span></code></pre><p>ここでhelloのELFを見てみます。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>readelf</span><span style=color:#a3be8c> -S hello</span><span style=color:#81a1c1> |</span><span style=color:#88c0d0> head</span><span style=color:#a3be8c> -n</span><span style=color:#b48ead> 11</span></span>
<span class=giallo-l><span style=color:#88c0d0>There</span><span style=color:#a3be8c> are</span><span style=color:#b48ead> 41</span><span style=color:#a3be8c> section headers, starting at offset 0x8e4e4:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>Section</span><span style=color:#a3be8c> Headers:</span></span>
<span class=giallo-l><span style=color:#eceff4>  [</span><span>Nr</span><span style=color:#eceff4>]</span><span style=color:#88c0d0> Name</span><span style=color:#a3be8c>              Type            Addr     Off    Size   ES Flg Lk Inf Al</span></span>
<span class=giallo-l><span style=color:#eceff4>  [</span><span> 0</span><span style=color:#eceff4>]</span><span style=color:#88c0d0>                   NULL</span><span style=color:#b48ead>            00000000 000000 000000 00      0   0  0</span></span>
<span class=giallo-l><span style=color:#eceff4>  [</span><span> 1</span><span style=color:#eceff4>]</span><span style=color:#88c0d0> .note.ABI-tag</span><span style=color:#a3be8c>     NOTE            080480d4 0000d4</span><span style=color:#b48ead> 000020 00</span><span style=color:#a3be8c>   A</span><span style=color:#b48ead>  0   0  4</span></span>
<span class=giallo-l><span style=color:#eceff4>  [</span><span> 2</span><span style=color:#eceff4>]</span><span style=color:#88c0d0> .note.gnu.build-i</span><span style=color:#a3be8c> NOTE            080480f4 0000f4</span><span style=color:#b48ead> 000024 00</span><span style=color:#a3be8c>   A</span><span style=color:#b48ead>  0   0  4</span></span>
<span class=giallo-l><span style=color:#eceff4>  [</span><span> 3</span><span style=color:#eceff4>]</span><span style=color:#88c0d0> .rel.plt</span><span style=color:#a3be8c>          REL</span><span style=color:#b48ead>             08048118 000118 000028 08</span><span style=color:#a3be8c>   A</span><span style=color:#b48ead>  0   5  4</span></span>
<span class=giallo-l><span style=color:#eceff4>  [</span><span> 4</span><span style=color:#eceff4>]</span><span style=color:#88c0d0> .init</span><span style=color:#a3be8c>             PROGBITS</span><span style=color:#b48ead>        08048140 000140 000030 00</span><span style=color:#a3be8c>  AX</span><span style=color:#b48ead>  0   0  4</span></span>
<span class=giallo-l><span style=color:#eceff4>  [</span><span> 5</span><span style=color:#eceff4>]</span><span style=color:#88c0d0> .plt</span><span style=color:#a3be8c>              PROGBITS</span><span style=color:#b48ead>        08048170 000170 000050 00</span><span style=color:#a3be8c>  AX</span><span style=color:#b48ead>  0   0  4</span></span>
<span class=giallo-l><span style=color:#eceff4>  [</span><span> 6</span><span style=color:#eceff4>]</span><span style=color:#88c0d0> .text</span><span style=color:#a3be8c>             PROGBITS        080481c0 0001c0 069b4c</span><span style=color:#b48ead> 00</span><span style=color:#a3be8c>  AX</span><span style=color:#b48ead>  0   0 16</span></span></code></pre><p><code>.text</code>の<code>Off</code>が<code>0001c0</code>になっており、これはファイルの先頭から<code>1c0</code>byte目からtext sectionが始まっていることを表しています。<br> 次にhexeditで<code>1c0</code>付近の<code>1f0</code>をみてみると、<code>55 89</code>となっています。<code>.text</code>の<code>Addr</code>は<code>080481c0</code>なので<code>080481f0</code>には<code>55 89</code>という命令があると予想できます。<p>実際に<code>objdump -d hello</code>で確認してみると<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>080481f0 &lt;__do_global_dtors_aux>:</span></span>
<span class=giallo-l><span> 80481f0:       55                      push   %ebp</span></span>
<span class=giallo-l><span> 80481f1:       89 e5                   mov    %esp,%ebp</span></span></code></pre><p><code>080481f0</code>から<code>55 89</code>という命令があり、ELF通りになっていることが確かめられました。<p>また、readelfには<code>--segments</code>と<code>--sections</code>というように、sectionとsegmentsという管理単位があり、sectionはlink時に、segmentsはprogram load時に参照されるという説明があります。<p>ELFについては<a href=https://zenn.dev/drumato/books/afc3e00a4c7f1d rel=external>最小限で理解しつつ作るELF parser入門 in Rust</a>という本をやってみたいなと思ってます。<h3 id=gong-you-raiburari><a aria-label="Anchor link for: gong-you-raiburari" class=zola-anchor href=#gong-you-raiburari>共有ライブラリ</a></h3><p>標準Cライブラリを動的にリンクしたhelloで、共有ライブラリの仕組みを調べます。<br> 共有ライブラリでは仮想メモリの仕組みを通して、各プロセスで共有されるので、内部では絶対アドレスで呼び出しを行えず、これに対処するためにGOTとPLTという仕組みがあるそうです。<br> いまいちこの辺りは理解出来ませんでした。<h2 id=di-9zhang-zui-shi-hua><a aria-label="Anchor link for: di-9zhang-zui-shi-hua" class=zola-anchor href=#di-9zhang-zui-shi-hua>第9章 最適化</a></h2><p>gccにはoptimization optionとして、<code>-O</code>があり、<code>-O0</code>,<code>-O1</code>,<code>-O2</code>,<code>-Os</code>等の指定ができる。<br> これらを指定した際に実際にはどのような変化が起こるのかをみていきます。<br> 具体的にはELF上での変化や命令数、アセンブラの変化を調べます。<br> <code>printf()</code>が<code>puts()</code>になるのは知りませんでした。<h2 id=di-10zhang-yang-nahuan-jing-toyang-naakitekutiya><a aria-label="Anchor link for: di-10zhang-yang-nahuan-jing-toyang-naakitekutiya" class=zola-anchor href=#di-10zhang-yang-nahuan-jing-toyang-naakitekutiya>第10章 様々な環境と様々なアーキテクチャ</a></h2><p>これまではLinux/x86上でのhello worldを見てきましたが、このCentOS上でcompileされた実行ファイルはFreeBSD上で動作するでしょうか。<br> (FreeBSDのLinuxエミュレーション機能を利用しなければ)この実行ファイルは動作しません。理由は同じx86であってもFreeBSDのシステムコールABIが違うからです。<br> この章ではいろいろな環境でのシステムコール関連の実装を見ていきます。<br> システムコールのABIが違うとは具体的にどういうことなのか実際に見ることができて大変勉強になりました。<p>APIがPOSIXに準拠していれば、OS間で互換性があるというのは具体的にこういうことだったのかというが少しわかった様な気がしました。<h2 id=di-11zhang-ke-bian-chang-yin-shu-noxi-i><a aria-label="Anchor link for: di-11zhang-ke-bian-chang-yin-shu-noxi-i" class=zola-anchor href=#di-11zhang-ke-bian-chang-yin-shu-noxi-i>第11章 可変長引数の扱い</a></h2><p>printf()は可変長引数なのですが、この機能はアセンブラでどのように実現されているかを見ていきます。<br> x86では引数の個数と引数をスタックに積んで処理されていることがわかります。<br> ARM版の解説もあります。<h2 id=di-12zhang-jie-shuo-noji-da-cheng-sisutemukorunoqie-riti-ewojian-ru><a aria-label="Anchor link for: di-12zhang-jie-shuo-noji-da-cheng-sisutemukorunoqie-riti-ewojian-ru" class=zola-anchor href=#di-12zhang-jie-shuo-noji-da-cheng-sisutemukorunoqie-riti-ewojian-ru>第12章 解説の集大成 - システムコールの切り替えを見る</a></h2><p>この本を読んでみようとおもったきっかけの一つに<a href=https://github.com/cfsamson rel=external>cfsamson先生</a>の<a href=https://cfsamson.github.io/book-exploring-async-basics/3_1_communicating_with_the_os.html rel=external>The Node Experiment - Exploring Async Basics with Rust</a>という記事を読んでいた際にVDSOがでてきたからというのがあります。<br> そこでは<blockquote><p>The syscall instruction is a rather new one. On the earlier 32-bit systems in the x86 architecture, you invoked a syscall by issuing a software interrupt int 0x80. A software interrupt is considered slow at the level we're working at here so later a separate instruction for it called syscall was added. The syscall instruction uses VDSO, which is a memory page attached to each process' memory, so no context switch is necessary to execute the system call.</blockquote><p>と述べられており、最初は理解できなかったのですが、本章を読んでみて、言いたいことの概要が理解できました。<br> ただし、本章はかなり詳細にコード追っていくのですが現状の自分の力ではなかなか追いきれませんでした。<br> ただ、VDSOがどのレイヤーの話なのかはなんとなくわかったのでそれだけで現状では十分ということにしてます。<h2 id=matome><a aria-label="Anchor link for: matome" class=zola-anchor href=#matome>まとめ</a></h2><p>非常に勉強になる本でした。現時点で理解できていない箇所も多いですがそれでも読んでみてよかったと思っております。<br> 実行ファイルを命令レベルで読んでいくので、再現環境を用意してもらえているのが非常に助かりました。<br> ABI, UNIX互換、POSIX APIといった考えそれぞれが具体例付きで解説されており、非常に参考になりました。<p>FreeBSDのdirectory構造やソースコードがとても綺麗で興味沸きました。<h2 id=can-kao><a aria-label="Anchor link for: can-kao" class=zola-anchor href=#can-kao>参考</a></h2><ul><li><a href=http://kozos.jp/books/helloworld/ rel=external>本書のサポートページ</a><li><a href=https://imada.sdu.dk/u/kslarsen/dm546/Material/IntelnATT.htm rel=external>IntelとAT&T Syntaxの違い</a></ul></div></article></main><footer class=blog-footer><p>© 2026 <a href=https://blog.ymgyt.io> ymgyt </a> | Made with <a href=https://www.getzola.org rel=noopener target=_blank>Zola</a> | <a href=https://github.com/ymgyt/blog>Repository</a> | <a href=https://blog.ymgyt.io/atom.xml target=_blank title=rss> <svg viewbox="0 0 24 24" class=icon fill=none height=24 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx=5 cy=19 r=1></circle></svg> </a></footer></div></div>