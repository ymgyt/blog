<!doctype html><html lang=ja><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=https://blog.ymgyt.io/favicon.ico rel=icon sizes=any><link href=https://blog.ymgyt.io/icon.svg rel=icon type=image/svg+xml><link href=https://blog.ymgyt.io/apple-touch-icon.png rel=apple-touch-icon><link href=https://blog.ymgyt.io/manifest.webmanifest rel=manifest><link href=https://blog.ymgyt.io/style.css rel=stylesheet><link href=https://blog.ymgyt.io/atom.xml rel=alternate title=Atom type=application/atom+xml><script src="https://www.googletagmanager.com/gtag/js?id=G-GTB0KMLN90" async></script><script>window.dataLayer = window.dataLayer || [];
	function gtag() {dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-GTB0KMLN90');</script><title>📕 プログラマーのためのCPU入門を読んだ感想 | Happy developing</title><meta content=プログラマーのためのCPU入門がとてもわかりやすかったです name=description><meta content=summary name=twitter:card><meta content="@YAmaguchixt " name=twitter:site><meta content="📕 プログラマーのためのCPU入門を読んだ感想" name=twitter:title><meta content=プログラマーのためのCPU入門がとてもわかりやすかったです name=twitter:description><meta content=https://blog.ymgyt.io/images/emoji/closed_book.png name=twitter:image><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><body><div class=world><div class=content-container><header class=blog-header-container><div class=blog-logo><a href=https://blog.ymgyt.io>Happy developing</a></div><div class=blog-nav><nav><ul><li><a href=https://blog.ymgyt.io/entry/>Entries</a><li><a href=https://blog.ymgyt.io/tags/>Tags</a><li><a href=https://blog.ymgyt.io/about/>About</a><li><a href=https://github.com/ymgyt> <img alt=Github class=icon src=https://blog.ymgyt.io/images/icon/github.svg> </a><li><a href="https://twitter.com/YAmaguchixt "> <img alt=Twitter class=icon src=https://blog.ymgyt.io/images/icon/twitter.svg> </a></ul></nav></div></header><main class=blog-main><article><header class=entry-header><h1 class=entry-title>📕 プログラマーのためのCPU入門を読んだ感想</h1><div class=entry-meta><p class=entry-meta-item>🗓 2023-03-15<p class=entry-meta-item>🏷 <span class=tag><a href=https://blog.ymgyt.io/tags/book/>book</a></span></div></header><aside class=entry-toc><nav><ul class=entry-toc-toplevel-list><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#du-ndaben>読んだ本</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#matome>まとめ</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-1zhang-cpuharu-he-nisitesohutoueawogao-su-nishi-xing-surunoka>第1章 CPUは如何にしてソフトウェアを高速に実行するのか</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#cpunoxing-neng-toha>CPUの性能とは</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#ming-ling-liu>命令流</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-2zhang-ming-ling-nomi-du-woshang-gerusamazamanagong-fu>第2章 命令の密度を上げるさまざまな工夫</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-3zhang-detayi-cun-guan-xi>第3章 データ依存関係</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#ming-ling-reitensinoji-ce-shi-yan>命令レイテンシの計測実験</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-4zhang-fen-qi-ming-ling>第4章 分岐命令</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#fen-qi-yu-ce-misunoji-ce-shi-yan>分岐予測ミスの計測実験</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-5zhang-kiyatusiyumemori>第5章 キャッシュメモリ</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#kiyatusiyumisunoce-ding>キャッシュミスの測定</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-6zhang-jia-xiang-ji-yi>第6章 仮想記憶</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#tlbmisuji-ce-shi-yan>TLBミス計測実験</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-7zhang-i-o>第7章 I/O</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#i-oming-ling-niyorudebaisunozhi-nodu-michu-si>I/O命令によるデバイスの値の読み出し</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-8zhang-sisutemukoru-li-wai-ge-riip-mi>第8章 システムコール、例外、割り込み</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#sisutemukorutoli-wai-noshi-yan>システムコールと例外の実験</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-9zhang-marutipurosetusa>第9章 マルチプロセッサ</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-10zhang-kiyatusiyukohirensuzhi-yu>第10章 キャッシュコヒーレンス制御</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#kohirensumisunoshi-yan>コヒーレンスミスの実験</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-11zhang-memorishun-xu-fu-ke>第11章 メモリ順序付け</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#memoriodaringunoshi-yan>メモリオーダリングの実験</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-12zhang-bu-ke-fen-cao-zuo>第12章 不可分操作</a> <ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#bu-ke-fen-cao-zuo-noshi-yan>不可分操作の実験</a></ul><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#di-13zhang-gao-su-nasohutoueawoshu-kuji-nihahe-nizhu-mu-subekika>第13章 高速なソフトウェアを書く際には何に注目すべきか</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#fu-lu-a-cpunituitesaraniguang-kushen-kuzhi-runiha>付録A CPUについてさらに広く深く知るには</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#fu-lu-b-ge-cpunoji-ben-de-naming-ling>付録B 各CPUの基本的な命令</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#fu-lu-c-xian-dai-de-nacpunoshi-zhuang-li-boom>付録C 現代的なCPUの実装例 (BOOM)</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#fu-lu-d-maikurooperesiyonfang-shi-to-sonoming-ling-reitensi>付録D マイクロオペレーション方式と、その命令レイテンシ</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#fu-lu-e-gpuoyobibekutorufang-shi-niokerupaipurainnogao-mi-du-hua-nogong-fu>付録E GPUおよびベクトル方式におけるパイプラインの高密度化の工夫</a><li><a href=https://blog.ymgyt.io/entry/what-a-programmer-should-know-about-the-cpu/#fu-lu-f-cpunoxing-neng-xiang-shang-nowu-li-de-nanan-sisa>付録F CPUの性能向上の物理的な難しさ</a></ul></nav></aside><div class=entry-content><h2 id=du-ndaben><a aria-label="Anchor link for: du-ndaben" class=zola-anchor href=#du-ndaben>読んだ本</a></h2><a href=https://www.lambdanote.com/products/cpu> <figure><div class=fig-images-row><img , alt src=images/what-a-programmer-should-know-about-the-cpu-book.png></div></figure> </a><p><a href=https://www.lambdanote.com/products/cpu rel=external>プログラマーのためのCPU入門</a><br> 著者: Takenobu Tani<p>会社で読まれた方がオススメされており、読んでみたので感想を書きます。<br> 出版社は<a href=https://www.lambdanote.com/ rel=external>ラムダノート</a>です。<h2 id=matome><a aria-label="Anchor link for: matome" class=zola-anchor href=#matome>まとめ</a></h2><p>非常に良かったです。この本を出版してくれてありがとうございますという感謝の気持ちでいっぱいです。<br> 具体的には以下の点が良かったです。<ul><li>CPUの速度向上の為には命令流の密度を上げる必要がある -> そのための工夫 -> それにより発生する問題 -> 問題へのアプローチという章展開が非常にわかりやすかった<li>新しい概念(パイプライン、スーパースカラ、アウトオブオーダー, 分岐命令等)が登場する際に必ず図による説明がある<li>同じ概念がVendorや本(パタヘネ)では異なる用語で説明されている場合にその揺らぎを補足してくれる<li>x86/Arm両対応のAssemblyによる検証コードがあり、実際に登場した機能を確かめられる</ul><p>プログラムはメモリから命令を取得して順番に実行していく、くらいのメンタルモデルだと解像度が一段上がると思いました。<h2 id=di-1zhang-cpuharu-he-nisitesohutoueawogao-su-nishi-xing-surunoka><a aria-label="Anchor link for: di-1zhang-cpuharu-he-nisitesohutoueawogao-su-nishi-xing-surunoka" class=zola-anchor href=#di-1zhang-cpuharu-he-nisitesohutoueawogao-su-nishi-xing-surunoka>第1章 CPUは如何にしてソフトウェアを高速に実行するのか</a></h2><h3 id=cpunoxing-neng-toha><a aria-label="Anchor link for: cpunoxing-neng-toha" class=zola-anchor href=#cpunoxing-neng-toha>CPUの性能とは</a></h3><p>本書はCPUを性能の面から眺めるのですが、そもそも性能とはというところから始めてくれます。<p>$$ CPU時間 = \frac{実行命令数}{プログラム} \times \frac{クロックサイクル数}{実行命令数} \times \frac{秒数}{クロックサイクル数} $$<p>そして、CPUの性能とは、上記で定めるCPU時間が短いほどよいとします。<p>$$ CPU時間 = \frac{秒数}{プログラム} $$<p>のようにせず、わざわざ3項にしているかというと、各項がそれぞれ、CPUの異なる側面を表すからです。<br> 具体的には、第1項がプログラムを構成する命令数、コンパイラ、命令セットアーキテクチャによって決まります。<br> 第2項はCPUの内部構造(microarchitecture)、第3項は半導体や回路実装技術がそれぞれ対応します。<h3 id=ming-ling-liu><a aria-label="Anchor link for: ming-ling-liu" class=zola-anchor href=#ming-ling-liu>命令流</a></h3><p>プログラムをbuild/compileして機械語にしてCPUに渡しますが、CPUからこの機械語がどう見えているかというと、ある種の命令流として見えていると説明されます。<br> そして本書ではこの命令流を早くするためにCPUが行っている工夫と、遅くなる要因という観点から章が構成されます。<h2 id=di-2zhang-ming-ling-nomi-du-woshang-gerusamazamanagong-fu><a aria-label="Anchor link for: di-2zhang-ming-ling-nomi-du-woshang-gerusamazamanagong-fu" class=zola-anchor href=#di-2zhang-ming-ling-nomi-du-woshang-gerusamazamanagong-fu>第2章 命令の密度を上げるさまざまな工夫</a></h2><p>CPUの命令流を速くするためにその密度に着目します。密度というのは、実行中のCPUのスナップショットを採ったときにどれくらいの命令が実行中かという概念と理解しています。<p>まず逐次処理から始めます。<figure><div class=fig-images-row><img , alt src=images/pipe_1.svg></div><figcaption>逐次処理</figcaption></figure><p>これはある命令の実行を完了してから次の命令の実行を開始する処理方法です。実行中のCPUのどの時点でも1つの命令しか実行していないので密度としては最も低い状態です。<br> さらに、命令実行の各処理(ステージ)を考慮すると逐次処理は以下のように表すことができます。<figure><div class=fig-images-row><img , alt src=images/pipe_2.svg></div><figcaption>ステージaware</figcaption></figure><p>次にパイプライン化します。今までは前の命令の実行完了まで待ってから次の命令を実行していましたが、完了まで待つのではなく、ステージの完了まで待ってから次の命令を実行します。<br> この結果、ある1時点をみるとステージ数の命令が実行中となります。<figure><div class=fig-images-row><img , alt src=images/pipe_3.svg></div><figcaption>パイプライン化</figcaption></figure><p>なお、パイプライン化により、前の命令の実行の完了を待たずに次の命令を実行することになります。これは広い意味での「投機的な処理」を導入するものと説明されます。このことが次章以降のデータ依存関係や、分岐命令の話につながります。<p>そして、このパイプラインを物理的に複数設けるアプローチがスーパースカラ化です。<figure><div class=fig-images-row><img , alt src=images/pipe_4.svg></div><figcaption>スーパースカラ化</figcaption></figure><p>最後に、ステージ分割を更に推し進め(スーパーパイプライン化)し、スーパースカラの並列度を4に、ステージ分割数を12にすると現代の標準的なCPUと同程度の規模感になるそうです。<figure><div class=fig-images-row><img , alt src=images/pipe_5.svg></div><figcaption>4並列、12段ステージ</figcaption></figure><p>最初の逐次処理と比較すると密度が向上していることがわかります。<br> スーパースカラやパイプライン化は概念としては知っていましたが命令流の密度という観点から整理してくれている本章の説明はとてもわかりやすかったです。<h2 id=di-3zhang-detayi-cun-guan-xi><a aria-label="Anchor link for: di-3zhang-detayi-cun-guan-xi" class=zola-anchor href=#di-3zhang-detayi-cun-guan-xi>第3章 データ依存関係</a></h2><p>第2章で導入されたパイプライン化により命令流の密度を高めることができました。ただし、パイプライン化によって、先の命令の実行完了を待たずに次の命令の実行が開始されます。<br> これによって命令間に依存関係がある場合に問題が生じます。具体的には<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>add x1, x2, x3</span></span>
<span class=giallo-l><span>sub x4, x5, x1</span></span></code></pre><p>のように<code>add</code>命令で更新したregisterを後続の<code>sub</code>命令で利用する場合、<code>add</code>命令の完了によってx1 registerが更新されてからでないと<code>sub</code>命令が実行できません。<br> この命令を待機している間はパイプラインのステージの一部が利用されていない状態となってしまい、命令流の密度が低下してしまいます。<br> そこで、依存関係によって待機している命令を実行する代わりに別の命令を先に実行することで、ステージの空きを埋めるアウトオブオーダーという手法が導入されます。<br> また、データの依存関係にもいろいろ種類があり、依存関係の種類によっては、registerのリネームで対応できるといった説明もあります。<p>アウトオブオーダーの存在自体は、<a href=https://blog.ymgyt.io/entry/rust_atomics_and_locks/ rel=external>Atomics and Locksを読んで</a>知っていたのですがどういう理由でそれが実行されるかはわかっていなかったので本章の説明はとてもわかりやすかったです。<h3 id=ming-ling-reitensinoji-ce-shi-yan><a aria-label="Anchor link for: ming-ling-reitensinoji-ce-shi-yan" class=zola-anchor href=#ming-ling-reitensinoji-ce-shi-yan>命令レイテンシの計測実験</a></h3><p>実際に各種命令(add,mul,load)のレイテンシを計測するassemblyのサンプルがあります。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> sudo perf stat -e</span><span style=color:#eceff4>"</span><span style=color:#a3be8c>cycles,instructions</span><span style=color:#eceff4>"</span><span style=color:#a3be8c> ./latency_add</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>loop-variable</span><span style=color:#a3be8c> =</span><span style=color:#b48ead> 10000000</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0> Performance</span><span style=color:#a3be8c> counter stats for</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>./latency_add</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>     1,001,224,176</span><span style=color:#a3be8c>      cycles</span><span>                                                      </span></span>
<span class=giallo-l><span style=color:#88c0d0>     1,031,181,195</span><span style=color:#a3be8c>      instructions</span><span style=color:#616e88>              #    1.03  insn per cycle         </span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.213554069</span><span style=color:#a3be8c> seconds time elapsed</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.213500000</span><span style=color:#a3be8c> seconds user</span></span>
<span class=giallo-l><span style=color:#88c0d0>       0.000000000</span><span style=color:#a3be8c> seconds sys</span></span></code></pre><p>となり、add命令については1cycleで実行していることが確かめられました。<br> 0.2秒程度で10億回の命令が実行されるのはすごいです。<br> この他にも依存関係を変えるとどう変化するかの実験もあります。<p>検証環境は以下です。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>$ uname --kernel-name --kernel-release  --machine --processor --hardware-platform --operating-system</span></span>
<span class=giallo-l><span>Linux 5.19.0-35-generic x86_64 x86_64 x86_64 GNU/Linux </span></span></code></pre><h2 id=di-4zhang-fen-qi-ming-ling><a aria-label="Anchor link for: di-4zhang-fen-qi-ming-ling" class=zola-anchor href=#di-4zhang-fen-qi-ming-ling>第4章 分岐命令</a></h2><p>アウトオブオーダーをもってしてもカバーできない命令流の密度低下要因に分岐命令があります。<br> というのも、ifのような命令は実行して条件成立を判断したのちに、pc registerを更新することで命令流を切り替えるので分岐命令の後の命令の実行が全て無駄になる可能性があります。<p>そこで、これに対処するために分岐予測という仕組みがCPUに実装されます。<br> 分岐予測では、分岐命令が実行されるたびにその命令のアドレスと分岐先を専用の記憶領域(BTB)に保持しておき、命令をfetchする度にアドレスで検索して分岐命令かを判定します。さらに分岐命令の条件の成否の履歴を保持しておき、分岐予測に役立てるそうです。 ifを実行する度にCPUではこんなことが起きていると知り衝撃的でした。<br> 本章に限ったことではないですが、参考として米国特許までもが挙げられており筆者の知識の深さに驚かされます。<h3 id=fen-qi-yu-ce-misunoji-ce-shi-yan><a aria-label="Anchor link for: fen-qi-yu-ce-misunoji-ce-shi-yan" class=zola-anchor href=#fen-qi-yu-ce-misunoji-ce-shi-yan>分岐予測ミスの計測実験</a></h3><p>本章の実験では、分岐予測が50%ミスするプログラムと100%ヒットするプログラムでどの程度の差がでるかを検証します。<br> 以下が自分の手元の計測結果でした。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> sudo perf stat -e</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>cycles,instructions,branches,branch-misses</span><span style=color:#eceff4>"</span><span style=color:#a3be8c> ./branch_miss_many</span></span>
<span class=giallo-l><span style=color:#88c0d0>loop-variable</span><span style=color:#a3be8c> =</span><span style=color:#b48ead> 10000000</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0> Performance</span><span style=color:#a3be8c> counter stats for</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>./branch_miss_many</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       167,198,348</span><span style=color:#a3be8c>      cycles</span><span>                                                      </span></span>
<span class=giallo-l><span style=color:#88c0d0>       155,965,644</span><span style=color:#a3be8c>      instructions</span><span style=color:#616e88>              #    0.93  insn per cycle         </span></span>
<span class=giallo-l><span style=color:#88c0d0>        20,179,030</span><span style=color:#a3be8c>      branches</span><span>                                                    </span></span>
<span class=giallo-l><span style=color:#88c0d0>         5,003,075</span><span style=color:#a3be8c>      branch-misses</span><span style=color:#616e88>             #   24.79% of all branches        </span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.039321696</span><span style=color:#a3be8c> seconds time elapsed</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.039277000</span><span style=color:#a3be8c> seconds user</span></span>
<span class=giallo-l><span style=color:#88c0d0>       0.000000000</span><span style=color:#a3be8c> seconds sys</span></span></code></pre><p>2000万 branchesとありますが、この内半分はloopの判定なので実質的には1000万で、missが500万となっています。<br> 次が分岐予測がほとんどあたる場合です。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> sudo perf stat -e</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>cycles,instructions,branches,branch-misses</span><span style=color:#eceff4>"</span><span style=color:#a3be8c> ./branch_miss_few</span></span>
<span class=giallo-l><span style=color:#88c0d0>loop-variable</span><span style=color:#a3be8c> =</span><span style=color:#b48ead> 10000000</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0> Performance</span><span style=color:#a3be8c> counter stats for</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>./branch_miss_few</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>        66,698,390</span><span style=color:#a3be8c>      cycles</span><span>                                                      </span></span>
<span class=giallo-l><span style=color:#88c0d0>       150,937,374</span><span style=color:#a3be8c>      instructions</span><span style=color:#616e88>              #    2.26  insn per cycle         </span></span>
<span class=giallo-l><span style=color:#88c0d0>        20,174,821</span><span style=color:#a3be8c>      branches</span><span>                                                    </span></span>
<span class=giallo-l><span style=color:#88c0d0>             5,368</span><span style=color:#a3be8c>      branch-misses</span><span style=color:#616e88>             #    0.03% of all branches        </span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.017504270</span><span style=color:#a3be8c> seconds time elapsed</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.017500000</span><span style=color:#a3be8c> seconds user</span></span>
<span class=giallo-l><span style=color:#88c0d0>       0.000000000</span><span style=color:#a3be8c> seconds sys</span></span></code></pre><p>着目すべきは、cycle数が40%程度減っていおり、実行速度も40%程度向上しました。<br> このように分岐予測の影響が実際に確かめることができました。<h2 id=di-5zhang-kiyatusiyumemori><a aria-label="Anchor link for: di-5zhang-kiyatusiyumemori" class=zola-anchor href=#di-5zhang-kiyatusiyumemori>第5章 キャッシュメモリ</a></h2><p>CPUからメモリへのアクセスには10 ~ 100サイクル程度を要する。そしてアウトオブオーダー実行で埋められるサイクル数にも限界がある。そこで、CPU、メモリ間にキャッシュが導入されます。<br> メモリへの書き込みはキャッシュになされるのでキャッシュとメモリ間の不整合が発生することとなるがこの問題は10章で扱います。<p>キャッシュを導入したとしてもキャッシュミス自体は避けられず、その影響は大きい。<br> そこでキャッシュミスが起きやすい場合を3つに類型化し、それぞれ対策していきます。<br> まず初期参照ミスに対してはキャッシュラインで、容量性ミスに対しては階層化、競合性ミスにはセットアソシアティブ方式で対処します。<br> キャッシュの話でキャッシュラインや階層化がよく説明されますが、それをキャッシュミスの類型と対応させる説明がわかりやすかったです。<br> また、自分はフルアソシアティブ方式とセットアソシアティブ方式の違いやway数というものがよくわかっていなかったので本章説明は非常にありがたかったです。<br> 普段のアプリケーションでキャッシュラインを意識することはほとんどないのですが、ライブラリのコードを見ているとキャッシュラインを意識したコメントを時々見かけることもあります。現状ではstructを64byte以内にしておくとキャッシュに乗りやすいくらいの理解度です。<h3 id=kiyatusiyumisunoce-ding><a aria-label="Anchor link for: kiyatusiyumisunoce-ding" class=zola-anchor href=#kiyatusiyumisunoce-ding>キャッシュミスの測定</a></h3><p>本章ではキャッシュミスがどのように影響するかを実験します。以下がキャッシュをミスさせるプログラム。<br> アドレスの増分値として4096を利用しました。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> sudo perf stat -e</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>cycles,instructions,L1-dcache-loads,L1-dcache-load-misses</span><span style=color:#eceff4>"</span><span style=color:#a3be8c> ./cache_miss_many</span></span>
<span class=giallo-l><span style=color:#88c0d0>loop-variable</span><span style=color:#a3be8c> =</span><span style=color:#b48ead> 10000000</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0> Performance</span><span style=color:#a3be8c> counter stats for</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>./cache_miss_many</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>        22,006,883</span><span style=color:#a3be8c>      cycles</span><span>                                                      </span></span>
<span class=giallo-l><span style=color:#88c0d0>        91,018,467</span><span style=color:#a3be8c>      instructions</span><span style=color:#616e88>              #    4.14  insn per cycle         </span></span>
<span class=giallo-l><span style=color:#88c0d0>        10,257,315</span><span style=color:#a3be8c>      L1-dcache-loads</span><span>                                             </span></span>
<span class=giallo-l><span style=color:#88c0d0>         8,954,362</span><span style=color:#a3be8c>      L1-dcache-load-misses</span><span style=color:#616e88>     #   87.30% of all L1-dcache accesses</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.008935091</span><span style=color:#a3be8c> seconds time elapsed</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.008868000</span><span style=color:#a3be8c> seconds user</span></span>
<span class=giallo-l><span style=color:#88c0d0>       0.000000000</span><span style=color:#a3be8c> seconds sys</span></span></code></pre><p>次が、メモリアクセスがキャッシュラインにのるようなプログラムです。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> sudo perf stat -e</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>cycles,instructions,L1-dcache-loads,L1-dcache-load-misses</span><span style=color:#eceff4>"</span><span style=color:#a3be8c> ./cache_miss_few</span></span>
<span class=giallo-l><span style=color:#88c0d0>loop-variable</span><span style=color:#a3be8c> =</span><span style=color:#b48ead> 10000000</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0> Performance</span><span style=color:#a3be8c> counter stats for</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>./cache_miss_few</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>        21,923,146</span><span style=color:#a3be8c>      cycles</span><span>                                                      </span></span>
<span class=giallo-l><span style=color:#88c0d0>        90,949,898</span><span style=color:#a3be8c>      instructions</span><span style=color:#616e88>              #    4.15  insn per cycle         </span></span>
<span class=giallo-l><span style=color:#88c0d0>        10,239,289</span><span style=color:#a3be8c>      L1-dcache-loads</span><span>                                             </span></span>
<span class=giallo-l><span style=color:#88c0d0>            12,032</span><span style=color:#a3be8c>      L1-dcache-load-misses</span><span style=color:#616e88>     #    0.12% of all L1-dcache accesses</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.008941629</span><span style=color:#a3be8c> seconds time elapsed</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.008911000</span><span style=color:#a3be8c> seconds user</span></span>
<span class=giallo-l><span style=color:#88c0d0>       0.000000000</span><span style=color:#a3be8c> seconds sys</span></span></code></pre><p>0.1%程度しかミスしていないようです。<br> 自分の環境では実行速度に差がでませんでした。<h2 id=di-6zhang-jia-xiang-ji-yi><a aria-label="Anchor link for: di-6zhang-jia-xiang-ji-yi" class=zola-anchor href=#di-6zhang-jia-xiang-ji-yi>第6章 仮想記憶</a></h2><p>Virtual addressとphysical addressの変換を行うレイヤーが仮想記憶。 仮想記憶を導入することで様々なメリットがある一方で、対応関係の情報自体(ページテーブル)はメモリ上にある。したがって、メモリにアクセスする際には対応関係の解決のためにメモリアクセスが必要になるので都合2回のアクセスが必要となってしまう。<br> これではキャッシュが解決しようとした問題と同じことが起きてしまう。そこで、ページテーブルの一部をCPU上に保持すること(TLB)でアドレス解決時のメモリアクセスを抑えるようにする。<p>自分はページテーブルとTLBの関係の理解が曖昧だったので、本章の説明もとてもありがたかったです。<br> また、プロセスよりもスレッドの方が切り替えコストが低い理由としてTLBのキャッシュミスが影響しているのもなるほどでした。<br> 加えてページテーブルを大きくしたい動機がわかっていなかったので、TLBのキャッシュミスを下げられるという説明もとてもわかりやすかったです。<p>CPUの命令流の密度を高めるための工夫を知ると、ページフォルト時にI/Oが発生したらもう今までの苦労が全部水の泡になるというのが腹落ちできたのもうれしいです。<h3 id=tlbmisuji-ce-shi-yan><a aria-label="Anchor link for: tlbmisuji-ce-shi-yan" class=zola-anchor href=#tlbmisuji-ce-shi-yan>TLBミス計測実験</a></h3><p>キャッシュライン同様に、TLBミスの影響を実験します。 以下はTLBがヒットするプログラムです。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> sudo perf stat -e</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>cycles,instructions,L1-dcache-loads,dTLB-loads,dTLB-load-misses</span><span style=color:#eceff4>"</span><span style=color:#a3be8c> ./tlb_miss_few</span></span>
<span class=giallo-l><span style=color:#88c0d0>loop-variable</span><span style=color:#a3be8c> =</span><span style=color:#b48ead> 100000000</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0> Performance</span><span style=color:#a3be8c> counter stats for</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>./tlb_miss_few</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       243,254,513</span><span style=color:#a3be8c>      cycles</span><span>                                                      </span></span>
<span class=giallo-l><span style=color:#88c0d0>       901,372,541</span><span style=color:#a3be8c>      instructions</span><span style=color:#616e88>              #    3.71  insn per cycle         </span></span>
<span class=giallo-l><span style=color:#88c0d0>       100,349,655</span><span style=color:#a3be8c>      L1-dcache-loads</span><span>                                             </span></span>
<span class=giallo-l><span style=color:#88c0d0>       100,349,655</span><span style=color:#a3be8c>      dTLB-loads</span><span>                                                  </span></span>
<span class=giallo-l><span style=color:#88c0d0>               899</span><span style=color:#a3be8c>      dTLB-load-misses</span><span style=color:#616e88>          #    0.00% of all dTLB cache accesses</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.054821090</span><span style=color:#a3be8c> seconds time elapsed</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.054809000</span><span style=color:#a3be8c> seconds user</span></span>
<span class=giallo-l><span style=color:#88c0d0>       0.000000000</span><span style=color:#a3be8c> seconds sys</span></span></code></pre><p>次に、TLBをミスさせるプログラムです。変更点は、参照するメモリアドレスを一定範囲に抑えるコードをなくし、参照するページ数を増やしただけです。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> sudo perf stat -e</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>cycles,instructions,L1-dcache-loads,dTLB-loads,dTLB-load-misses</span><span style=color:#eceff4>"</span><span style=color:#a3be8c> ./tlb_miss_many</span></span>
<span class=giallo-l><span style=color:#88c0d0>loop-variable</span><span style=color:#a3be8c> =</span><span style=color:#b48ead> 100000000</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0> Performance</span><span style=color:#a3be8c> counter stats for</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>./tlb_miss_many</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>     1,919,208,667</span><span style=color:#a3be8c>      cycles</span><span>                                                      </span></span>
<span class=giallo-l><span style=color:#88c0d0>       913,274,488</span><span style=color:#a3be8c>      instructions</span><span style=color:#616e88>              #    0.48  insn per cycle         </span></span>
<span class=giallo-l><span style=color:#88c0d0>       103,472,076</span><span style=color:#a3be8c>      L1-dcache-loads</span><span>                                             </span></span>
<span class=giallo-l><span style=color:#88c0d0>       103,472,076</span><span style=color:#a3be8c>      dTLB-loads</span><span>                                                  </span></span>
<span class=giallo-l><span style=color:#88c0d0>        97,106,889</span><span style=color:#a3be8c>      dTLB-load-misses</span><span style=color:#616e88>          #   93.85% of all dTLB cache accesses</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.405079023</span><span style=color:#a3be8c> seconds time elapsed</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.405029000</span><span style=color:#a3be8c> seconds user</span></span>
<span class=giallo-l><span style=color:#88c0d0>       0.000000000</span><span style=color:#a3be8c> seconds sys</span></span></code></pre><p>自分の環境では実行時間が7倍程度増加しました。<br> TLBミスの影響が確認できました。<h2 id=di-7zhang-i-o><a aria-label="Anchor link for: di-7zhang-i-o" class=zola-anchor href=#di-7zhang-i-o>第7章 I/O</a></h2><p>CPUの命令実行によりCPUから外部のデバイスにアクセスする仕組みについて。<br> 自分は、メモリマップドI/Oと専用のI/O命令によるアクセスの方式をごっちゃになって理解していたので、本章の整理は非常に助かりました。<br> また、DMAコントローラとCPUの関係の説明もわかりやすかったです。<h3 id=i-oming-ling-niyorudebaisunozhi-nodu-michu-si><a aria-label="Anchor link for: i-oming-ling-niyorudebaisunozhi-nodu-michu-si" class=zola-anchor href=#i-oming-ling-niyorudebaisunozhi-nodu-michu-si>I/O命令によるデバイスの値の読み出し</a></h3><p>本章の実験では、real time clock(RTC)やPCI Expressの情報を読み出すプログラムを試します。<br> 残念ながら自分のPCではSegmentation faultとなってうまくいきませんでしたが、I/Oがin,out命令から実現されていることがわかります。<h2 id=di-8zhang-sisutemukoru-li-wai-ge-riip-mi><a aria-label="Anchor link for: di-8zhang-sisutemukoru-li-wai-ge-riip-mi" class=zola-anchor href=#di-8zhang-sisutemukoru-li-wai-ge-riip-mi>第8章 システムコール、例外、割り込み</a></h2><p>分岐命令以外で、命令流の切り替えが起きるケースについて。<br> exception, interrupt, trap, fault, system call,...等を命令流の特別な切り替えという観点から整理してくれています。<br> 本書はCPUに関連するトピックを命令流という観点から整理してくれておりますが、本章の整理は特にわかりやすいです。<br> 定義の仕方にもよりますが、システムコール、例外、割り込みについてメンタルモデルを確立したいと思う方に本章はとてもおすすめしたいです。<p>またこれまでの章で、割り込みコントローラー, アドレス変換処理、キャッシュ、I/Oバス等にふれましたが、それら関連コンポーネントと各種事象がどう対応しているかの図が非常にわかりやすかったです。<br> 加えて、システムコール、例外、割り込み時の挙動の説明も具体的で、ベクターテーブルの説明もあります。<br> システムコールは遅いと漠然と思っていたのですが、なぜ遅いかが、これまでのパイプラインやキャッシュの観点から理解できます。章立てが練られていると思わされます。<h3 id=sisutemukorutoli-wai-noshi-yan><a aria-label="Anchor link for: sisutemukorutoli-wai-noshi-yan" class=zola-anchor href=#sisutemukorutoli-wai-noshi-yan>システムコールと例外の実験</a></h3><p>実際にシステムコールを実行してみます。<br> システムコール自体は、仕様を把握できていれさえすれば、引数をregisterに設定したのち、専用の命令を実行するだけというのがわかります。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span> /* write(2) system-call */</span></span>
<span class=giallo-l><span> mov     eax, 1                  /* system-call number: write() */</span></span>
<span class=giallo-l><span> mov     edi, 1                  /* fd: stdout */</span></span>
<span class=giallo-l><span> lea     rsi, [rip + msg]        /* buf: */</span></span>
<span class=giallo-l><span> mov     edx, 13                 /* count: */</span></span>
<span class=giallo-l><span> syscall</span></span></code></pre><p><a href=https://blog.ymgyt.io/entry/helloworld-book/ rel=external>Hello World本</a>で学んだことですが、これはx86 + linuxの仕様であって、system callの引数をregisterではなくstack経由で渡すというのも設計上はありえるという理解です。<p>また、ゼロ除算やページフォールトの例もあります。<h2 id=di-9zhang-marutipurosetusa><a aria-label="Anchor link for: di-9zhang-marutipurosetusa" class=zola-anchor href=#di-9zhang-marutipurosetusa>第9章 マルチプロセッサ</a></h2><p>2つ以上のCPUによって構成される場合について。<br> マルチプロセッサとマルチコアの文脈による使い分けの説明がなるほどでした。<br> 自分はマルチコアと言った際に想定されるハードウェア構成は一つだと思っていたのですが、多様な構成が可能なのが勉強になりました。<br> 特に、メッセージ交換型でメモリ共有がなされていない場合があるとは思ってもみなかったです。<h2 id=di-10zhang-kiyatusiyukohirensuzhi-yu><a aria-label="Anchor link for: di-10zhang-kiyatusiyukohirensuzhi-yu" class=zola-anchor href=#di-10zhang-kiyatusiyukohirensuzhi-yu>第10章 キャッシュコヒーレンス制御</a></h2><p>前章で説明された共有メモリ型における問題点と対処法について。<br> 具体的には、CPUごとにcacheを保持することとなるので、同一メモリアドレスのコピーが複数存在するため、他のCPUの更新結果が別のCPUから読めないといったキャッシュ間の整合性が崩れる問題に対処する必要がある。<br> キャッシュコヒーレンスの問題状況を丁寧に説明してくれるので、MSIプロトコルの立ち位置が理解しやすかったです。<br> 最初にキャッシュコヒーレンスの話を知った際は、変数に書き込むと裏ではCPU間で当該キャッシュを無効にするやり取りが行われているなんて思いもしませんでした。<h3 id=kohirensumisunoshi-yan><a aria-label="Anchor link for: kohirensumisunoshi-yan" class=zola-anchor href=#kohirensumisunoshi-yan>コヒーレンスミスの実験</a></h3><p>本章の実験では、2つのthreadで、互いにメモリを変更し合うプログラムを動かします。<br> その際、変更対象のメモリのキャッシュラインが同じか異なるかでどのような影響が観測されるかを検証します。<p>まずthread間でキャッシュラインを共有しない場合です。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> sudo perf stat -e</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>cycles,instructions,L1-dcache,L1-dcache-load-misses</span><span style=color:#eceff4>"</span><span style=color:#a3be8c> ./cacheline_different</span></span>
<span class=giallo-l><span style=color:#88c0d0>main</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child1</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child2</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child2</span><span style=color:#eceff4>()</span><span>: finish</span></span>
<span class=giallo-l><span style=color:#88c0d0>child1</span><span style=color:#eceff4>()</span><span>: finish</span></span>
<span class=giallo-l><span style=color:#88c0d0>main</span><span style=color:#eceff4>()</span><span>: finish</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0> Performance</span><span style=color:#a3be8c> counter stats for</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>./cacheline_different</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>        71,827,869</span><span style=color:#a3be8c>      cycles</span><span>                                                      </span></span>
<span class=giallo-l><span style=color:#88c0d0>        61,149,657</span><span style=color:#a3be8c>      instructions</span><span style=color:#616e88>              #    0.85  insn per cycle         </span></span>
<span class=giallo-l><span style=color:#88c0d0>        10,288,943</span><span style=color:#a3be8c>      L1-dcache</span><span>                                                   </span></span>
<span class=giallo-l><span style=color:#88c0d0>            19,262</span><span style=color:#a3be8c>      L1-dcache-load-misses</span><span style=color:#616e88>     #    0.19% of all L1-dcache accesses</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.012914616</span><span style=color:#a3be8c> seconds time elapsed</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.024334000</span><span style=color:#a3be8c> seconds user</span></span>
<span class=giallo-l><span style=color:#88c0d0>       0.000000000</span><span style=color:#a3be8c> seconds sys</span></span></code></pre><p>ミス率が0.19%とほとんどないことがわかります。<br> 次はキャッシュラインを共有する場合です。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> sudo perf stat -e</span><span style=color:#eceff4> "</span><span style=color:#a3be8c>cycles,instructions,L1-dcache,L1-dcache-load-misses</span><span style=color:#eceff4>"</span><span style=color:#a3be8c> ./cacheline_same</span></span>
<span class=giallo-l><span style=color:#88c0d0>main</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child1</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child2</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child2</span><span style=color:#eceff4>()</span><span>: finish</span></span>
<span class=giallo-l><span style=color:#88c0d0>child1</span><span style=color:#eceff4>()</span><span>: finish</span></span>
<span class=giallo-l><span style=color:#88c0d0>main</span><span style=color:#eceff4>()</span><span>: finish</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0> Performance</span><span style=color:#a3be8c> counter stats for</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>./cacheline_same</span><span style=color:#eceff4>'</span><span style=color:#a3be8c>:</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       341,254,050</span><span style=color:#a3be8c>      cycles</span><span>                                                      </span></span>
<span class=giallo-l><span style=color:#88c0d0>        61,221,311</span><span style=color:#a3be8c>      instructions</span><span style=color:#616e88>              #    0.18  insn per cycle         </span></span>
<span class=giallo-l><span style=color:#88c0d0>        10,306,873</span><span style=color:#a3be8c>      L1-dcache</span><span>                                                   </span></span>
<span class=giallo-l><span style=color:#88c0d0>         1,431,930</span><span style=color:#a3be8c>      L1-dcache-load-misses</span><span style=color:#616e88>     #   13.89% of all L1-dcache accesses</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.041625362</span><span style=color:#a3be8c> seconds time elapsed</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0>       0.080869000</span><span style=color:#a3be8c> seconds user</span></span>
<span class=giallo-l><span style=color:#88c0d0>       0.000000000</span><span style=color:#a3be8c> seconds sys</span></span></code></pre><p>キャッシュミス率が70倍程度増加し、実行時間が3倍程度増加しました。 キャッシュラインのフォールスシェアリングの影響があることが確かめられました。<h2 id=di-11zhang-memorishun-xu-fu-ke><a aria-label="Anchor link for: di-11zhang-memorishun-xu-fu-ke" class=zola-anchor href=#di-11zhang-memorishun-xu-fu-ke>第11章 メモリ順序付け</a></h2><p>1つのCPUから複数のメモリアクセスに何らかの順序関係を強制する手段としてのmemory orderingについて。<br> なぜメモリアクセスが一つのCPU内で入れ替わるのかの説明が参考になります。<br> fence命令の必要性や、acquire, release命令の動作が具体例つきでわかりやすいです。<br> また、本章で説明されるメモリ順序付けは1つのCPUからのメモリアクセスについてである点が強調されています。そのため、本章とRust Atomics and Locksを併せて読むのがオススメです。<br> fenceやldar, stlr命令があくまで1CPUに対する制約であり、happens-before relationshipとは別の話と整理できて非常に理解が進みました。<h3 id=memoriodaringunoshi-yan><a aria-label="Anchor link for: memoriodaringunoshi-yan" class=zola-anchor href=#memoriodaringunoshi-yan>メモリオーダリングの実験</a></h3><p>本章の実験では実際にCPUが命令を入れ替えて実行していることを実験します。<br> 具体的には、0に初期化された変数x,yに対して、以下の二つのthreadを実行します。<ul><li>thread1: x = 1を実施したのち、yをload<li>thread2: y = 1を実施したのち、xをload</ul><p>命令がインオーダーに実行されていればthreadの実行順序に関わらず、x = 0, y = 0という状態には至らないはずです。<br> しかしながら、x86であってもloadとstore間では実行順序の入れ替えが起こることが許容されていることから、実際にx = 0, y = 0という状態が観測されます。<br> 実際に試してみると以下のようになりました。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> ./ordering_unexpected</span><span> </span></span>
<span class=giallo-l><span style=color:#88c0d0>main</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child1</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child2</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child2</span><span style=color:#eceff4>()</span><span>: UNEXPECTED</span><span style=color:#81a1c1>!</span><span style=color:#88c0d0>:</span><span style=color:#a3be8c> r14 ==</span><span style=color:#b48ead> 0</span><span style=color:#eceff4> &&</span><span style=color:#88c0d0> r15</span><span style=color:#a3be8c> ==</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>;</span><span style=color:#88c0d0> loop-variable</span><span style=color:#a3be8c> =</span><span style=color:#b48ead> 5</span></span>
<span class=giallo-l><span style=color:#88c0d0>child1</span><span style=color:#eceff4>()</span><span>: UNEXPECTED</span><span style=color:#81a1c1>!</span><span style=color:#88c0d0>:</span><span style=color:#a3be8c> r14 ==</span><span style=color:#b48ead> 0</span><span style=color:#eceff4> &&</span><span style=color:#88c0d0> r15</span><span style=color:#a3be8c> ==</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>;</span><span style=color:#88c0d0> loop-variable</span><span style=color:#a3be8c> =</span><span style=color:#b48ead> 5</span></span>
<span class=giallo-l><span style=color:#88c0d0>main</span><span style=color:#eceff4>()</span><span>: finish</span></span></code></pre><p>続いて、storeとload間にメモリフェンス命令を挿入した例を試します。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>mov     [rip + value_x], rax    /* value_x = 1   */</span></span>
<span class=giallo-l><span>mfence                          /* FORCE ORDERING */</span></span>
<span class=giallo-l><span>mov     r14, [rip + value_y]    /* r14 = value_y */</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>$</span><span style=color:#a3be8c> ./ordering_force</span></span>
<span class=giallo-l><span style=color:#88c0d0>main</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child1</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child2</span><span style=color:#eceff4>()</span><span>: start</span></span>
<span class=giallo-l><span style=color:#88c0d0>child1</span><span style=color:#eceff4>()</span><span>: finish: loop-variable = 5000000</span></span>
<span class=giallo-l><span style=color:#88c0d0>child2</span><span style=color:#eceff4>()</span><span>: finish: loop-variable = 5000000</span></span>
<span class=giallo-l><span style=color:#88c0d0>main</span><span style=color:#eceff4>()</span><span>: finish</span></span></code></pre><p>メモリフェンス命令が実際に命令の入れ替えを抑止していることが確かめられました。<h2 id=di-12zhang-bu-ke-fen-cao-zuo><a aria-label="Anchor link for: di-12zhang-bu-ke-fen-cao-zuo" class=zola-anchor href=#di-12zhang-bu-ke-fen-cao-zuo>第12章 不可分操作</a></h2><p>本章では共通のメモリを2つ以上のCPU間で相互に更新する場合についてです。<br> メモリオーダリングに比べて、不可分操作の話は解決したい問題がわかりやすく、解決法も専用の命令使うという話で意外とわかりやすい印象があります。<br> swapやcompare and swap命令がどのように動作するのかの説明があります。このあたりはプログラム言語でもそのままapiになっている気がするので、内部動作を知るのが結局近道だと思いました。<h3 id=bu-ke-fen-cao-zuo-noshi-yan><a aria-label="Anchor link for: bu-ke-fen-cao-zuo-noshi-yan" class=zola-anchor href=#bu-ke-fen-cao-zuo-noshi-yan>不可分操作の実験</a></h3><p>本章の実験では、共有変数をthread間でインクリメントする際にatomic命令を使わないとどうなるかを検証します。<p>具体的には以下のようにatomic命令を使ってインクリメントする場合<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>lock xadd [rip + counter], rax</span></span></code></pre><p>と単純なadd命令を使う場合を比較します。<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>add     rax, 1</span></span></code></pre><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>$ ./counter_atomic</span></span>
<span class=giallo-l><span>main(): start</span></span>
<span class=giallo-l><span>child1(): start</span></span>
<span class=giallo-l><span>child2(): start</span></span>
<span class=giallo-l><span>child2(): finish: loop-variable = 5000000</span></span>
<span class=giallo-l><span>child1(): finish: loop-variable = 5000000</span></span>
<span class=giallo-l><span>main(): finish: counter = 10000000</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>$ ./counter_bad</span></span>
<span class=giallo-l><span>main(): start</span></span>
<span class=giallo-l><span>child1(): start</span></span>
<span class=giallo-l><span>child2(): start</span></span>
<span class=giallo-l><span>child2(): finish: loop-variable = 5000000</span></span>
<span class=giallo-l><span>child1(): finish: loop-variable = 5000000</span></span>
<span class=giallo-l><span>main(): finish: counter = 5133651 </span></span></code></pre><p>add命令を利用する<code>./counter_bad</code>の方では、counterが意図通りになっていないことが確認できました。<br> またadd命令を使った場合でもthread間のアクセス頻度ではcounterの値がより意図通りになる例も載っており、この種のバグの厄介さがわかります。<h2 id=di-13zhang-gao-su-nasohutoueawoshu-kuji-nihahe-nizhu-mu-subekika><a aria-label="Anchor link for: di-13zhang-gao-su-nasohutoueawoshu-kuji-nihahe-nizhu-mu-subekika" class=zola-anchor href=#di-13zhang-gao-su-nasohutoueawoshu-kuji-nihahe-nizhu-mu-subekika>第13章 高速なソフトウェアを書く際には何に注目すべきか</a></h2><p>これまでのまとめ。<br> 高速なソフトウェアを書くうえで、何に着目するかは、実行対象のソフトウェアだけでなくプログラミング言語、OS、CPU等にも依存するため難しい問題。<br> そんな中、大枠としてどのようにアプローチできるかについて教えてくれます。<h2 id=fu-lu-a-cpunituitesaraniguang-kushen-kuzhi-runiha><a aria-label="Anchor link for: fu-lu-a-cpunituitesaraniguang-kushen-kuzhi-runiha" class=zola-anchor href=#fu-lu-a-cpunituitesaraniguang-kushen-kuzhi-runiha>付録A CPUについてさらに広く深く知るには</a></h2><p>CPUについてさらに詳しく知りたい人に向けた情報源の紹介。<br> 書籍だけでなく、論文や特許、講義資料も載っておりすごいです。 自分は、Systems Performance Second Edition(詳解システム・パフォーマンス 第2版)を読んでみようと思っております。<br> あとがきにも著者のオススメがのっているので要チェックです。<h2 id=fu-lu-b-ge-cpunoji-ben-de-naming-ling><a aria-label="Anchor link for: fu-lu-b-ge-cpunoji-ben-de-naming-ling" class=zola-anchor href=#fu-lu-b-ge-cpunoji-ben-de-naming-ling>付録B 各CPUの基本的な命令</a></h2><p>x86, Arm, RISC-Vそれぞれの基本的な命令を解説してくれます。<br> 自分のアセンブリの学習ソースが基本的に本のappendixなので非常にありがたいです。<br> RISC-Vは比較命令で暗黙的なレジスタを更新しないという学びもありました。<h2 id=fu-lu-c-xian-dai-de-nacpunoshi-zhuang-li-boom><a aria-label="Anchor link for: fu-lu-c-xian-dai-de-nacpunoshi-zhuang-li-boom" class=zola-anchor href=#fu-lu-c-xian-dai-de-nacpunoshi-zhuang-li-boom>付録C 現代的なCPUの実装例 (BOOM)</a></h2><p><a href=https://boom-core.org/ rel=external>BOOM</a>というRISC-Vの実装について。<br> まったく読めてないです。<br> Chiselで書かれているらしいです。いつもハードウェア記述言語の文脈で突然Scalaでてきて驚きます。<h2 id=fu-lu-d-maikurooperesiyonfang-shi-to-sonoming-ling-reitensi><a aria-label="Anchor link for: fu-lu-d-maikurooperesiyonfang-shi-to-sonoming-ling-reitensi" class=zola-anchor href=#fu-lu-d-maikurooperesiyonfang-shi-to-sonoming-ling-reitensi>付録D マイクロオペレーション方式と、その命令レイテンシ</a></h2><p>x86のようなCISCで出てくるマイクロオペレーションについて。<br> 今まで、アセンブリってCPUが実際に実行している機械語と1:1対応していると思っていたのですが、もはやアセンブリでさえ抽象化されたレイヤーなのかと思ってしまいます。<h2 id=fu-lu-e-gpuoyobibekutorufang-shi-niokerupaipurainnogao-mi-du-hua-nogong-fu><a aria-label="Anchor link for: fu-lu-e-gpuoyobibekutorufang-shi-niokerupaipurainnogao-mi-du-hua-nogong-fu" class=zola-anchor href=#fu-lu-e-gpuoyobibekutorufang-shi-niokerupaipurainnogao-mi-du-hua-nogong-fu>付録E GPUおよびベクトル方式におけるパイプラインの高密度化の工夫</a></h2><p>本章で扱えなかったGPUについて。<br> 自分はCPUとGPUって具体的にどう連携しているのかが知りたいです。<br> 7章によるとCPUからはI/OデバイスとしてGPUが見えているはずなので、I/O処理としてGPUに処理を依頼する感じになるのでしょうか。<br> でもそうなるとプログラミング言語からどうやって扱うのだろうか。<h2 id=fu-lu-f-cpunoxing-neng-xiang-shang-nowu-li-de-nanan-sisa><a aria-label="Anchor link for: fu-lu-f-cpunoxing-neng-xiang-shang-nowu-li-de-nanan-sisa" class=zola-anchor href=#fu-lu-f-cpunoxing-neng-xiang-shang-nowu-li-de-nanan-sisa>付録F CPUの性能向上の物理的な難しさ</a></h2><p>CPUの物理的な側面について。<br> <del>物理も学びたいです</del></div></article></main><footer class=blog-footer><p>© 2026 <a href=https://blog.ymgyt.io> ymgyt </a> | Made with <a href=https://www.getzola.org rel=noopener target=_blank>Zola</a> | <a href=https://github.com/ymgyt/blog>Repository</a> | <a href=https://blog.ymgyt.io/atom.xml target=_blank title=rss> <svg viewbox="0 0 24 24" class=icon fill=none height=24 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx=5 cy=19 r=1></circle></svg> </a></footer></div></div>