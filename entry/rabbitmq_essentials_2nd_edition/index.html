<!doctype html><html lang=ja><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=https://blog.ymgyt.io/favicon.ico rel=icon sizes=any><link href=https://blog.ymgyt.io/icon.svg rel=icon type=image/svg+xml><link href=https://blog.ymgyt.io/apple-touch-icon.png rel=apple-touch-icon><link href=https://blog.ymgyt.io/manifest.webmanifest rel=manifest><link href=https://blog.ymgyt.io/style.css rel=stylesheet><link href=https://blog.ymgyt.io/atom.xml rel=alternate title=Atom type=application/atom+xml><script src="https://www.googletagmanager.com/gtag/js?id=G-GTB0KMLN90" async></script><script>window.dataLayer = window.dataLayer || [];
	function gtag() {dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-GTB0KMLN90');</script><title>📗 RabbitMQ Essentials 2nd Editionを読んだ感想 | Happy developing</title><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><body><div class=world><div class=content-container><header class=blog-header-container><div class=blog-logo><a href=https://blog.ymgyt.io>Happy developing</a></div><div class=blog-nav><nav><ul><li><a href=https://blog.ymgyt.io/entry/>Entries</a><li><a href=https://blog.ymgyt.io/tags/>Tags</a><li><a href=https://blog.ymgyt.io/about/>About</a><li><a href=https://github.com/ymgyt> <img alt=Github class=icon src=https://blog.ymgyt.io/images/icon/github.svg> </a><li><a href="https://twitter.com/YAmaguchixt "> <img alt=Twitter class=icon src=https://blog.ymgyt.io/images/icon/twitter.svg> </a></ul></nav></div></header><main class=blog-main><article><header class=entry-header><h1 class=entry-title>📗 RabbitMQ Essentials 2nd Editionを読んだ感想</h1><div class=entry-meta><p class=entry-meta-item>🗓 2022-08-17<p class=entry-meta-item>🏷 <span class=tag><a href=https://blog.ymgyt.io/tags/book/>book</a></span></div></header><aside class=entry-toc><nav><ul class=entry-toc-toplevel-list><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#du-ndaben-green-book>読んだ本📗</a><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#1-a-rabbit-springs-to-life>1 A Rabbit Springs to Life</a><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#2-creating-a-taxi-application>2 Creating a Taxi Application</a><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#3-sending-messages-to-multiple-taxi-drivers>3 Sending Messages to Multiple Taxi Drivers</a><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#4-tweaking-message-delivery>4 Tweaking Message Delivery</a><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#5-message-routing>5 Message Routing</a><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#6-taking-rabbitmq-to-production>6 Taking RabbitMQ to Production</a><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#7-best-practices-and-broker-monitoring>7 Best Practices and Broker Monitoring</a> <ul><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#monitoring>Monitoring</a></ul><li><a href=https://blog.ymgyt.io/entry/rabbitmq_essentials_2nd_edition/#matome>まとめ</a></ul></nav></aside><div class=entry-content><h2 id=du-ndaben-green-book><a aria-label="Anchor link for: du-ndaben-green-book" class=zola-anchor href=#du-ndaben-green-book>読んだ本📗</a></h2><figure><div class=fig-images-row><img , alt src=images/rabbitmq_essentials_book.png></div><figcaption>By Lovisa Johansson , David Dossot</figcaption></figure><p><a href=https://www.packtpub.com/product/rabbitmq-essentials-second-edition/9781789131666 rel=external>RabbitMQ Essentials - Second Edition</a><p>2020出版でRabbitMQ関連の本で比較的新しめだったのと、Taxi ApplicationにRabbitMQを組み込んでいくという形がおもしろそうだったので読んでみました。<h2 id=1-a-rabbit-springs-to-life><a aria-label="Anchor link for: 1-a-rabbit-springs-to-life" class=zola-anchor href=#1-a-rabbit-springs-to-life>1 A Rabbit Springs to Life</a></h2><p>概要やインストールについて。<br> RabbitMQ/AMQP 0-9-1のコンセプトについて紹介されています。<h2 id=2-creating-a-taxi-application><a aria-label="Anchor link for: 2-creating-a-taxi-application" class=zola-anchor href=#2-creating-a-taxi-application>2 Creating a Taxi Application</a></h2><p>Complete Car(CC)というタクシー予約システムを作りながらRabbitMQの使い方を学んでいきます。<br> 最初はDirect exchangeを利用しつつ、機能拡張という形でTopic exchangeを導入します。 その中で、Connection/Channelの説明や、基本的なPublish/Consumer APIの説明があります。<br> RabbitMQ Serverのrestartをまたいでmessageを永続化させるには、queueのdurableとmessageのpersistentの両方が必要になります。<br> messageの信頼性とパフォーマンスのトレードオフを見極めて利用する必要があるので、導入に際してはシステムに要求される信頼性を定義することが重要そうだなと考えました。<br> サンプルコードはRubyでした。<h2 id=3-sending-messages-to-multiple-taxi-drivers><a aria-label="Anchor link for: 3-sending-messages-to-multiple-taxi-drivers" class=zola-anchor href=#3-sending-messages-to-multiple-taxi-drivers>3 Sending Messages to Multiple Taxi Drivers</a></h2><p>Consumerに一度に送られるmessage数を制御するためのprefetch countとacknowledgeについて説明されます。messageの性質にもよりますが、prefetch countを1にしてmanual acknowledgeにしておくのが一番安全そう。 prefetch countはdefault値にたよらず明示的に指定しておくことも大事だなと思いました。<p>また、全taxiにback officeからメッセージを送りたいという機能要望に答えるためにFanout exchangeがCCに導入されました。<h2 id=4-tweaking-message-delivery><a aria-label="Anchor link for: 4-tweaking-message-delivery" class=zola-anchor href=#4-tweaking-message-delivery>4 Tweaking Message Delivery</a></h2><p>taxiのdriverにmessageを送るfanout exchangeをchapter3で導入した。<br> ところが運用してみるとmessageをまったくconsumeしないdriverが存在しており、queueにmessageが溜まり続けてしまう。そこで一定期間経過後にmessageを削除し、その際messageが重要であればdriverにメール送る機能を実装したい。というシナリオでtime to live(TTL)やDead letter Queueについて学んでいきます。<p>messageのexpirationについては以下の3つの選択肢がある。<ol><li>Standard AMQP message expiration property<li>QueueごとにmessageのTTLを定義できるRabbitMQ extension<li>Queue自体のTTLを定義できるRabbitMQ extension</ol><p>1についてはAMQP標準ということで魅力的だが、落とし穴があり、messageがqueueの先頭にきてはじめてTTLがチェックされるという仕様でTTLが過ぎていてもqueue自体には残ってしまう。<br> また、queue自体は削除したくないので3も除外。ということで選択肢2を採用することとなる。 TTLが過ぎたmessageはdead letterと判断される。RabbitMQはこうしたdead letterをDLXというexchangeにroutingする機能をもつ。<p>QueueにTTLやDLXを設定するには、queue declare時のargumentsに<code>x-message-ttl</code>や<code>x-dead-letter-{exchange,routing-key}</code>を指定するのですが、既存のqueueに対して宣言してしまうとargumentsが一致せずexceptionが発生してしまいます。<br> そこで、RabbitMQにはpolicyという仕組みがあり、policyを通して既存のqueueやexchangeに変更を適用できます。<p>PolicyはAMQPの仕様ではないのでclientにAPIがありません。(あるlibもあるかもしれませんが)<br> そこで、rabbitmqctlという専用のcliを利用します。<br> dockerでRabbitMQをたちあげている場合は<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=shellscript><span class=giallo-l><span style=color:#88c0d0>docker</span><span style=color:#a3be8c> exec rabbitmq-rabbitmq-1 -it /bin/bash</span></span>
<span class=giallo-l><span style=color:#88c0d0>rabbitmqctl</span><span style=color:#a3be8c> set_policy -p / Q_TTL_DLX</span><span style=color:#eceff4> '</span><span style=color:#a3be8c>.*</span><span style=color:#eceff4>' '</span><span style=color:#a3be8c>{"message-ttl": 1000, "dead-letter-exchange": "dlx"}</span><span style=color:#eceff4>'</span><span style=color:#a3be8c> --apply-to queues</span></span></code></pre><p>のようにします。<br> <code>-p</code>はvirtual hostの指定(なぜp?), <code>Q_TTL_DLX</code>はpolicyの名前。<code>'.*'</code>は適用するリソースの正規表現。jsonはpolicyのbody, <code>--apply-to</code>で適用対象をqueueかexchangeか指定といった感じです。<p>続いての機能拡張は、backofficeからtaxi driverにメッセージを送る際に、driver用のqueueがセットアップされていなければemailを送るようにしたいというものです。ここで利用できるのが、publish時の<code>mandatory</code> flagです。これはexchangeに送られたmessageがどのqueueにも送られなかった場合にpublisherにmessageを送り返す機能を有効にします。<br> lapinの<a href=https://github.com/amqp-rs/lapin/blob/lapin-1.x/examples/publisher_confirms.rs rel=external>publisher_confirms example</a>で実際の利用例がみれます。<h2 id=5-message-routing><a aria-label="Anchor link for: 5-message-routing" class=zola-anchor href=#5-message-routing>5 Message Routing</a></h2><p>ConsumerからPublisherにresponseを返すRPCを実装します。やり方はRabbitMQ TutorialsのRPCと同じで、messageのbasic propertiesにあるreply-toにresponse用のqueueを指定するだけです。request-response毎にqueueを生成するか事前に作成しておくかの方法があります。<p>また、Single Text-Oriented Message Protocol(STOMP)用のpluginを利用して、browserからRabbitMQ Serverにwebsocketで接続してqueueをsubscribeする例も紹介されています。<p>最後にheaders exchangeを導入します。topic exchangeではユースケースに対応できない場合にはheaders exchangeを利用する感じなのでしょうか。紹介されている事例は新しくqueueをたててbindingすれば対応できるように思えたのでいまいち使い所がわかっていません。<h2 id=6-taking-rabbitmq-to-production><a aria-label="Anchor link for: 6-taking-rabbitmq-to-production" class=zola-anchor href=#6-taking-rabbitmq-to-production>6 Taking RabbitMQ to Production</a></h2><p>今まではRabbitMQをsingle nodeで動かしていましたがこの章ではclusterを導入します。RabbitMQはErlangで実装されているらしく、clusterもErlang clustering featureを利用して実装されているみたいです。<p>Client libraryの実装によるかとは思うのですがcluster化した際にclient側でclusterを構成するnodeを把握してそれぞれの接続情報を保持しておく必要がありそうでした。Rustの実装であるlapinでは複数の接続先を渡せるようになっていないように見えるので、どう対応するかが課題です。(deadpool_lapinでConnection生成処理が隠蔽されているので、自分でurlをrotateするとかもできないので困りました)<p>RabbitMQのclusterではexchangeやqueueはnode間でsyncされるが、queueのmessageに関してはいくつか選択肢があるようです。<br> まず、Mirroring queuesという選択肢があります。これはmaster, replica構成でmessageを冗長化する方式のようです。<p>次に、quorum queuesという方式があります。これもmaster replicaベースですが、queueの内容についてleaderとreplication間で合意をとることで信頼性を高めているようです。過半数のnode間でqueueの内容がsyncできたらclientにconfirmを返すことで実現されています。<p>最後にLazy queuesが紹介されます。 この機能が有効かされたqueueではmessageはdistに保存され、queueにmessageが大量に溜まる場合でもRAMの使用量が抑えられるみたいです。durableを有効にするのと違ってそもそもメモリにmessageを保持しなくなる点が特徴という理解でよいのでしょうか。<p>Clusterに続いてはlogのaggregationを実現するためのfederationについても説明がありました。RabbitMQをfluentdのagentのように位置付けることもでき柔軟性が高いなと思いました。<h2 id=7-best-practices-and-broker-monitoring><a aria-label="Anchor link for: 7-best-practices-and-broker-monitoring" class=zola-anchor href=#7-best-practices-and-broker-monitoring>7 Best Practices and Broker Monitoring</a></h2><p>RabbitMQを運用していくにあたってのBest Practicesについての紹介です。<br> まずは、messageを失わないためのBest practicesについて。<ul><li>最低3台以上でclusterを組む<li>quorum queueを使う<li>queueをdurableにしてmessage publish時にpersistent delivery modeを有効にする<li>transient messageを利用してもLazy queuesの場合にはperformance上のtrade-offが発生する。また、queueがdurableであってもmessageが失われる可能性があることを理解しておく</ul><p>また、当然ではありますがdead letter exchangeを利用することも挙げられています。<br> messageのTTLやqueueのmax length, nack等でmessageが処理されないケースがあるのでエラーハンドリングもプログラム的につくっておきましょうと言われています。<p>performance的な問題がない限りはpublisher/consumerともにconfirmも有効にすることをまずは検討したほうがよさそうです。<p>Messageのhandlingに関しては以下の点が挙げられています。<ul><li>message sizeは大き過ぎても小さ過ぎても問題 <ul><li>小さすぎるiterableなdataはchunk化してみる<li>大きすぎる場合は別のcomponentにoffloadできるか試みる</ul><li>consumerの処理時間に応じてprefetching valueを調整する</ul><p>queueとbrokersをcleanに保とうという点について指摘されています。<ul><li>queueにはTTL(<code>x-message-ttl</code>)を設定する<li>queueにはmax-lengthを指定する<li>使われていないqueueを削除する <ul><li><code>x-expires</code>で利用されなくなってから削除されるまでの期間を指定しておく<li>queueのauto-delete propertyを有効にする</ul></ul><p>その他、messageのrouting keyに応じてqueueを分散させるためのpluginが紹介されています。<h3 id=monitoring><a aria-label="Anchor link for: monitoring" class=zola-anchor href=#monitoring>Monitoring</a></h3><p>現在のRabbitMQ serverの情報を取得する方法としてはrabbitmqctlとREST APIの二つの手段がある。監視に有用なmetricsが紹介されています。<br> node/clusterの状態からqueueごとの処理状況、file descriptorやsocketの利用状況もAPIで取得できるのは助かりそうです。<h2 id=matome><a aria-label="Anchor link for: matome" class=zola-anchor href=#matome>まとめ</a></h2><p>本書を読んだ感想を簡単に書いていきました。<br> RabbitMQの各機能について具体例をふまえて紹介されており概要を把握するのに適していると思いました。<br> <a href=https://www.manning.com/books/rabbitmq-in-depth rel=external>RabbitMQ in Depth</a>という本を見つけたので次はこちらを読んでみようかなと思ってます。</div></article></main><footer class=blog-footer><p>© 2026 <a href=https://blog.ymgyt.io> ymgyt </a> | Made with <a href=https://www.getzola.org rel=noopener target=_blank>Zola</a> | <a href=https://github.com/ymgyt/blog>Repository</a> | <a href=https://blog.ymgyt.io/atom.xml target=_blank title=rss> <svg viewbox="0 0 24 24" class=icon fill=none height=24 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx=5 cy=19 r=1></circle></svg> </a></footer></div></div>