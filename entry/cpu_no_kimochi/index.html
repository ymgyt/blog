<!doctype html><html lang=ja><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=https://blog.ymgyt.io/favicon.ico rel=icon sizes=any><link href=https://blog.ymgyt.io/icon.svg rel=icon type=image/svg+xml><link href=https://blog.ymgyt.io/apple-touch-icon.png rel=apple-touch-icon><link href=https://blog.ymgyt.io/manifest.webmanifest rel=manifest><link href=https://blog.ymgyt.io/style.css rel=stylesheet><link href=https://blog.ymgyt.io/atom.xml rel=alternate title=Atom type=application/atom+xml><script src="https://www.googletagmanager.com/gtag/js?id=G-GTB0KMLN90" async></script><script>window.dataLayer = window.dataLayer || [];
	function gtag() {dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-GTB0KMLN90');</script><title>📗 もっとCPUの気持ちが知りたいですか？を読んだ感想 | Happy developing</title><meta content=CPUの気持ち本を読んだ感想 name=description><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><body><div class=world><div class=content-container><header class=blog-header-container><div class=blog-logo><a href=https://blog.ymgyt.io>Happy developing</a></div><div class=blog-nav><nav><ul><li><a href=https://blog.ymgyt.io/entry/>Entries</a><li><a href=https://blog.ymgyt.io/tags/>Tags</a><li><a href=https://blog.ymgyt.io/about/>About</a><li><a href=https://github.com/ymgyt> <img alt=Github class=icon src=https://blog.ymgyt.io/images/icon/github.svg> </a><li><a href="https://twitter.com/YAmaguchixt "> <img alt=Twitter class=icon src=https://blog.ymgyt.io/images/icon/twitter.svg> </a></ul></nav></div></header><main class=blog-main><article><header class=entry-header><h1 class=entry-title>📗 もっとCPUの気持ちが知りたいですか？を読んだ感想</h1><div class=entry-meta><p class=entry-meta-item>🗓 2022-11-27<p class=entry-meta-item>🏷 <span class=tag><a href=https://blog.ymgyt.io/tags/book/>book</a></span></div></header><aside class=entry-toc><nav><ul class=entry-toc-toplevel-list><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#du-ndaben>読んだ本</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#matome>まとめ</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-1zhang-cpunoqi-chi-tiwozhi-rutoiukoto>第1章 CPUの気持ちを知るということ</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-2zhang-cputoyou-da-ninarou>第2章 CPUと友達になろう</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-3zhang-asenburiyan-yu-wonantonakudu-mu>第3章 アセンブリ言語をなんとなく読む</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-4zhang-cpuwozatukuriba-wo-suru>第4章 CPUをざっくり把握する</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-5zhang-zhi-woxi-u-rezisuta>第5章 値を扱う(レジスター)</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-6zhang-cpugadekirukotohaduo-kunai-ming-ling>第6章 CPUができることは多くない(命令)</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-7zhang-dao-hafen-kareru-fen-qi-ming-ling>第7章 道は分かれる(分岐命令)</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-8zhang-sinpurunacpu-fu-za-nacpu-risctocisc>第8章 シンプルなCPU、複雑なCPU(RISCとCISC)</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-9zhang-ji-yi-noshi-zu-mi-meinmemori>第9章 記憶の仕組み(メインメモリ)</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-10zhang-chu-li-woxiao-lu-yokushi-xing-surushi-zu-mi-paipurain>第10章 処理を効率よく実行する仕組み(パイプライン)</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-11zhang-shou-gajie-kufan-wei-nimonogaarutobian-li-dayone-kiyatusiyumemori>第11章 手が届く範囲にモノがあると便利だよね(キャッシュメモリ)</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-12zhang-cputozhou-bian-ji-qi-tonojie-bituki-i-o>第12章 CPUと周辺機器との結びつき(I/O)</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#di-13zhang-duo-kunoshi-shi-wochai-siip-mareruli-chang-desu-ge-riip-mi>第13章 多くの仕事を差し込まれる立場です(割り込み)</a><li><a href=https://blog.ymgyt.io/entry/cpu_no_kimochi/#fu-lu-a-ci-nidu-mubekiben>付録A 次に読むべき本</a></ul></nav></aside><div class=entry-content><h2 id=du-ndaben><a aria-label="Anchor link for: du-ndaben" class=zola-anchor href=#du-ndaben>読んだ本</a></h2><figure><div class=fig-images-row><img , alt src=images/cpu_no_kimochi_book.png></div><figcaption>出村 成和 著</figcaption></figure><p><a href=https://peaks.cc/cpu_no_kimochi rel=external>もっとCPUの気持ちが知りたいですか？</a><br> タイトルに惹かれて読んでみたので感想を書きます。(電子書籍 初版) 目次は<a href=https://peaks.cc/cpu_no_kimochi rel=external>本書のWebページ</a>から見れます。<br> 以下のような方が対象読者として挙げられていました。<blockquote><p>■ CPU の内部で行われていること（主にソフトウェア方面）を理解したい人</blockquote><blockquote><p>■ CPU の挙動を理解した上でコードを書きたい人</blockquote><h2 id=matome><a aria-label="Anchor link for: matome" class=zola-anchor href=#matome>まとめ</a></h2><ul><li>CPUについて知りたいと思った際に最初に読む本としてオススメしたいです。自分は最初にこの本読んでおきたかったなと思いました。</ul><h2 id=di-1zhang-cpunoqi-chi-tiwozhi-rutoiukoto><a aria-label="Anchor link for: di-1zhang-cpunoqi-chi-tiwozhi-rutoiukoto" class=zola-anchor href=#di-1zhang-cpunoqi-chi-tiwozhi-rutoiukoto>第1章 CPUの気持ちを知るということ</a></h2><p>CPUの気持ち(CPUの仕組みや行われている処理)を理解しているとどういったメリットがあるかについて。<p>Flutterといったクロスプラットフォームなフレームワークを使っていても肌間でOSやプラットフォーム依存の実装が必要な箇所が1~2割くらいあるという話がのっていました。以前React Nativeを利用したプロジェクトの際にiOS詳しい方がそういった箇所を担当されており、そういうものなのだなと思いました。<p>ソフトウェアを<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>アプリケーション  </span></span>
<span class=giallo-l><span>ミドルウェア</span></span>
<span class=giallo-l><span>ライブラリ</span></span>
<span class=giallo-l><span>os (software)</span></span>
<span class=giallo-l><span>-------------</span></span>
<span class=giallo-l><span>cpu (hardware)</span></span></code></pre><p>というスタックとして捉えるとCPUがsoftとhardの境界にあたるのでアプリケーションとcpuの知識からミドルウェアやosを学ぶアプローチが紹介されていました。<br> 自分は最近<a href=https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/ rel=external>Green Threads Explained in 200 Lines of Rust</a>という記事を読んでいたのですが、Green threads(Goのgoroutine等)を理解するためには結局CPUの内部構造わかっている必要があり、CPUへの理解は必須でどうにか理解を深めたいと思っていました。<p>また、CPUと関連の知識はプログラミング言語の挙動の理解にも有用であるとされており、例としてポインターが挙げられていました。<br> 自分がプログラミングでCPUの理解が足りていないと強く感じたのは、<a href=https://doc.rust-lang.org/nomicon/atomics.html rel=external>atomicのordering関連</a>です。 <a href=https://www.oreilly.co.jp/books/9784873119595/ rel=external>並行プログラミング入門</a>で<code>atomic::Ordering::SeqCst</code>等がCPUのどういった命令に対応しているといった話がでてきて、CPUについてもっと知りたいなと思うようになりました。<h2 id=di-2zhang-cputoyou-da-ninarou><a aria-label="Anchor link for: di-2zhang-cputoyou-da-ninarou" class=zola-anchor href=#di-2zhang-cputoyou-da-ninarou>第2章 CPUと友達になろう</a></h2><p>実行ファイルの概要を、加算を行う処理をCで書いて、compileしたのちobjdumpでdisassembleしながら説明してくれます。<h2 id=di-3zhang-asenburiyan-yu-wonantonakudu-mu><a aria-label="Anchor link for: di-3zhang-asenburiyan-yu-wonantonakudu-mu" class=zola-anchor href=#di-3zhang-asenburiyan-yu-wonantonakudu-mu>第3章 アセンブリ言語をなんとなく読む</a></h2><p><code>x = 2</code>のような変数への代入が<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>mov w9, #2</span></span>
<span class=giallo-l><span>str w9, [sp, #24]</span></span></code></pre><p>のような命令に変換される例を通してアセンブリの概要の説明があります。<br> アセンブリってどうしても業務や日々の開発で使わないのでどうも身につかないです。Rustの実行ファイルを読めるようになるなら<a href=https://www.amazon.co.jp/dp/B07CMMVY5J rel=external>大熱血！ アセンブラ入門</a>等をやってみようかななどと思っていたりします。<h2 id=di-4zhang-cpuwozatukuriba-wo-suru><a aria-label="Anchor link for: di-4zhang-cpuwozatukuriba-wo-suru" class=zola-anchor href=#di-4zhang-cpuwozatukuriba-wo-suru>第4章 CPUをざっくり把握する</a></h2><p>CPUを構成するコンポーネントが命令を実行する際にどういった役割を果たすかが説明されます。<br> 命令セットアーキテクチャーとマイクロアーキテクチャーの２つを理解しておくとよいとされています。自分も最初はx86とamd64って同じなのか違うものなのか混乱していたりしました。<h2 id=di-5zhang-zhi-woxi-u-rezisuta><a aria-label="Anchor link for: di-5zhang-zhi-woxi-u-rezisuta" class=zola-anchor href=#di-5zhang-zhi-woxi-u-rezisuta>第5章 値を扱う(レジスター)</a></h2><p>レジスターについての説明。<br> 汎用レジスターといいつつ、汎用でなかったりする説明はもっと早く知りたかったです。<br> 暗黙的に変更されるステータスレジスターの説明が丁寧でわかりやすかったです。<h2 id=di-6zhang-cpugadekirukotohaduo-kunai-ming-ling><a aria-label="Anchor link for: di-6zhang-cpugadekirukotohaduo-kunai-ming-ling" class=zola-anchor href=#di-6zhang-cpugadekirukotohaduo-kunai-ming-ling>第6章 CPUができることは多くない(命令)</a></h2><p>命令を以下のように分類してそれぞれ説明してくれます。<ul><li>ロード/ストア命令<li>算術演算<li>論理演算<li>比較命令<li>並列命令<li>分岐命令<li>その他</ul><p>比較命令(<code>cmp</code>)って減算を行ってステータスレジスターを更新する処理だったんですね。<br> SIMD命令について具体例もあってわかりやすかったです。<h2 id=di-7zhang-dao-hafen-kareru-fen-qi-ming-ling><a aria-label="Anchor link for: di-7zhang-dao-hafen-kareru-fen-qi-ming-ling" class=zola-anchor href=#di-7zhang-dao-hafen-kareru-fen-qi-ming-ling>第7章 道は分かれる(分岐命令)</a></h2><p>10章のパイプラインに関わってくることから分岐命令について、丁寧に説明されます。直前の命令の実行結果がステータスレジスターに書き戻されて初めて次に実行する命令が決まるという点がパイプライン処理で問題になるという理解です。<h2 id=di-8zhang-sinpurunacpu-fu-za-nacpu-risctocisc><a aria-label="Anchor link for: di-8zhang-sinpurunacpu-fu-za-nacpu-risctocisc" class=zola-anchor href=#di-8zhang-sinpurunacpu-fu-za-nacpu-risctocisc>第8章 シンプルなCPU、複雑なCPU(RISCとCISC)</a></h2><p>RISC(Reduced Instruction Set Computer)とCISC(Complex Instruction Set Computer)について。<br> ロード・ストア アーキテクチャーである点や命令が固定長であること等の観点からRISCとCISCを比較しながら説明してくれます。<br> RISCのReducedは命令数ではなくメモリアクセスへの頻度を指しているというのは知りませんでした。<h2 id=di-9zhang-ji-yi-noshi-zu-mi-meinmemori><a aria-label="Anchor link for: di-9zhang-ji-yi-noshi-zu-mi-meinmemori" class=zola-anchor href=#di-9zhang-ji-yi-noshi-zu-mi-meinmemori>第9章 記憶の仕組み(メインメモリ)</a></h2><p>CPUとメモリの関係について。<br> バイトオーダーやアライメントについての説明があります。<h2 id=di-10zhang-chu-li-woxiao-lu-yokushi-xing-surushi-zu-mi-paipurain><a aria-label="Anchor link for: di-10zhang-chu-li-woxiao-lu-yokushi-xing-surushi-zu-mi-paipurain" class=zola-anchor href=#di-10zhang-chu-li-woxiao-lu-yokushi-xing-surushi-zu-mi-paipurain>第10章 処理を効率よく実行する仕組み(パイプライン)</a></h2><p>命令の実行を複数の処理に分割して、同時に実行できる命令を増やすパイプラインについて。<br> 理想状態では、命令をもっとも効率的に実行し、1クロック1命令が実行できるが現実は次の命令を直ちに実行できない事情が存在する。<br> 代表例として、前回の結果に依存する場合と、条件分岐命令が挙げられる。 このような場合にもパイプラインの実行効率を落とさないための工夫があり、以下が解説されています。<ul><li>スーパースカラー<li>アウトオブオーダー実行<li>分岐予測<li>投機的実行</ul><p>最初にCPUの仕組みについて知りたいと思ったのはatomic関連の話で実際のプログラムはソースコードの通りに上から実行される訳ではないという話を知ったときでした。(<a href=https://doc.rust-lang.org/nomicon/atomics.html#hardware-reordering rel=external>さらにcompilerだけでなくhardware側でもreorderされたり</a>)<p>自分は分岐予測や投機的実行がよくわかっておらずこのあたりの解説が読みたいと思っていました。条件分岐やパイプラインが丁寧に説明されているのでなぜ分岐予測や投機的実行が必要かがとてもわかりやすかったです。<br> <code>if false { }</code>のように実行時にtrueでなくてもifのblockがCPUでは実行されているってすごいですよね。実行結果は捨てられるらしいのですが副作用ある処理だったらどうなるのかなという疑問が生じます。条件の結果がレジスターに書き戻されるまでの話だから投機的に実行されるのも数命令程度という話なのかもしれませんが。<p>分岐予測には、静的か動的かで分類できるそうです。<br> 静的分岐予測は、compilerが命令を並び替えたりする手法。具体的にどういった命令の並び替えが行われるかの具体例がなかったので気になりました。C++20では<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=cpp><span class=giallo-l><span style=color:#81a1c1>constexpr double</span><span style=color:#88c0d0> pow</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>double</span><span> x</span><span style=color:#eceff4>,</span><span style=color:#81a1c1> long long</span><span> n</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> noexcept</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    if</span><span style=color:#eceff4> (</span><span>n </span><span style=color:#81a1c1>></span><span style=color:#b48ead> 0</span><span style=color:#eceff4>) [[</span><span>likely</span><span style=color:#eceff4>]]</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span> x </span><span style=color:#81a1c1>*</span><span style=color:#88c0d0> pow</span><span style=color:#eceff4>(</span><span>x</span><span style=color:#eceff4>,</span><span> n </span><span style=color:#81a1c1>-</span><span style=color:#b48ead> 1</span><span style=color:#eceff4>)</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    else</span><span style=color:#eceff4> [[</span><span>unlikely</span><span style=color:#eceff4>]]</span></span>
<span class=giallo-l><span style=color:#81a1c1>        return</span><span style=color:#b48ead> 1</span><span style=color:#81a1c1>;</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span></code></pre><p>https://en.cppreference.com/w/cpp/language/attributes/likely<p>のようにifに<code>[[likely]]</code>と書いてソースコードで分岐に関する情報をcompilerに伝えられるようです。すごい。<h2 id=di-11zhang-shou-gajie-kufan-wei-nimonogaarutobian-li-dayone-kiyatusiyumemori><a aria-label="Anchor link for: di-11zhang-shou-gajie-kufan-wei-nimonogaarutobian-li-dayone-kiyatusiyumemori" class=zola-anchor href=#di-11zhang-shou-gajie-kufan-wei-nimonogaarutobian-li-dayone-kiyatusiyumemori>第11章 手が届く範囲にモノがあると便利だよね(キャッシュメモリ)</a></h2><p>CPUとcacheについて。<br> cacheを意識するかしないかでどれくらい速度に差がでるか検証するCのコードが載っていたので、Rustで書いて試してみました。<p><code>Cargo.toml</code><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=toml><span class=giallo-l><span style=color:#eceff4>[</span><span>dev-dependencies</span><span style=color:#eceff4>]</span></span>
<span class=giallo-l><span>criterion</span><span style=color:#eceff4> = "</span><span style=color:#a3be8c>0.3.0</span><span style=color:#eceff4>"</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#eceff4>[[</span><span>bench</span><span style=color:#eceff4>]]</span></span>
<span class=giallo-l><span>name</span><span style=color:#eceff4> = "</span><span style=color:#a3be8c>cache</span><span style=color:#eceff4>"</span></span>
<span class=giallo-l><span>harness</span><span style=color:#eceff4> =</span><span style=color:#81a1c1> false</span></span></code></pre><p><code>benches/cache.rs</code><pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=rust><span class=giallo-l><span style=color:#81a1c1>use</span><span> criterion</span><span style=color:#81a1c1>::</span><span style=color:#eceff4>{</span><span>criterion_group</span><span style=color:#eceff4>,</span><span> criterion_main</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> Criterion</span><span style=color:#eceff4>,</span><span style=color:#8fbcbb> BatchSize</span><span style=color:#eceff4>};</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>type</span><span style=color:#8fbcbb> Data</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> Vec</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>Vec</span><span style=color:#eceff4>&lt;</span><span style=color:#8fbcbb>i64</span><span style=color:#eceff4>>>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>const</span><span> D</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> i64</span><span style=color:#81a1c1> =</span><span style=color:#b48ead> 100</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#5e81ac>#[derive(</span><span style=color:#8fbcbb>Clone</span><span style=color:#5e81ac>)]</span></span>
<span class=giallo-l><span style=color:#81a1c1>struct</span><span style=color:#8fbcbb> Input</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>    buff_size</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> usize</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>    a</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> Data</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>    b</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> Data</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>    answer</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> Data</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> init_input</span><span style=color:#eceff4>(</span><span>buff_size</span><span style=color:#81a1c1>:</span><span style=color:#8fbcbb> usize</span><span style=color:#eceff4>)</span><span style=color:#81a1c1> -></span><span style=color:#8fbcbb> Input</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> answer</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0;font-weight:700> vec!</span><span style=color:#eceff4>[</span><span style=color:#88c0d0;font-weight:700>vec!</span><span style=color:#eceff4>[</span><span style=color:#b48ead>0_</span><span style=color:#8fbcbb>i64</span><span style=color:#eceff4>;</span><span> buff_size</span><span style=color:#eceff4>];</span><span> buff_size</span><span style=color:#eceff4>];</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let mut</span><span> a</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0;font-weight:700> vec!</span><span style=color:#eceff4>[</span><span style=color:#88c0d0;font-weight:700>vec!</span><span style=color:#eceff4>[</span><span style=color:#b48ead>0_</span><span style=color:#8fbcbb>i64</span><span style=color:#eceff4>;</span><span> buff_size</span><span style=color:#eceff4>];</span><span> buff_size</span><span style=color:#eceff4>];</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let mut</span><span> b</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0;font-weight:700> vec!</span><span style=color:#eceff4>[</span><span style=color:#88c0d0;font-weight:700>vec!</span><span style=color:#eceff4>[</span><span style=color:#b48ead>0_</span><span style=color:#8fbcbb>i64</span><span style=color:#eceff4>;</span><span> buff_size</span><span style=color:#eceff4>];</span><span> buff_size</span><span style=color:#eceff4>];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>    for</span><span> i</span><span style=color:#81a1c1> in</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>..</span><span>buff_size</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>        for</span><span> j</span><span style=color:#81a1c1> in</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>..</span><span>buff_size</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>            a</span><span style=color:#eceff4>[</span><span>i</span><span style=color:#eceff4>][</span><span>j</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> =</span><span> j</span><span style=color:#81a1c1> as</span><span style=color:#8fbcbb> i64</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span>            b</span><span style=color:#eceff4>[</span><span>i</span><span style=color:#eceff4>][</span><span>j</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> =</span><span> j</span><span style=color:#81a1c1> as</span><span style=color:#8fbcbb> i64</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#eceff4>        }</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#8fbcbb>    Input</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        buff_size</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>        a</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>        b</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span>        answer</span><span style=color:#eceff4>,</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> access_in_order</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Input</span><span style=color:#eceff4> {</span><span> buff_size</span><span style=color:#eceff4>,</span><span> a</span><span style=color:#eceff4>,</span><span> b</span><span style=color:#eceff4>,</span><span> answer</span><span style=color:#eceff4> }</span><span style=color:#81a1c1>: &mut</span><span style=color:#8fbcbb> Input</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> buff_size</span><span style=color:#81a1c1> = *</span><span>buff_size</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    for</span><span> i</span><span style=color:#81a1c1> in</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>..</span><span>buff_size</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>        for</span><span> j</span><span style=color:#81a1c1> in</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>..</span><span>buff_size</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>            answer</span><span style=color:#eceff4>[</span><span>i</span><span style=color:#eceff4>][</span><span>j</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> =</span><span> a</span><span style=color:#eceff4>[</span><span>i</span><span style=color:#eceff4>][</span><span>j</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> *</span><span> b</span><span style=color:#eceff4>[</span><span>i</span><span style=color:#eceff4>][</span><span>j</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> +</span><span style=color:#8fbcbb> D</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#eceff4>        }</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> access</span><span style=color:#eceff4>(</span><span style=color:#8fbcbb>Input</span><span style=color:#eceff4> {</span><span> buff_size</span><span style=color:#eceff4>,</span><span> a</span><span style=color:#eceff4>,</span><span> b</span><span style=color:#eceff4>,</span><span> answer</span><span style=color:#eceff4> }</span><span style=color:#81a1c1>: &mut</span><span style=color:#8fbcbb> Input</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> buff_size</span><span style=color:#81a1c1> = *</span><span>buff_size</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    for</span><span> i</span><span style=color:#81a1c1> in</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>..</span><span>buff_size</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span style=color:#81a1c1>        for</span><span> j</span><span style=color:#81a1c1> in</span><span style=color:#b48ead> 0</span><span style=color:#81a1c1>..</span><span>buff_size</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>            answer</span><span style=color:#eceff4>[</span><span>j</span><span style=color:#eceff4>][</span><span>i</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> =</span><span> a</span><span style=color:#eceff4>[</span><span>j</span><span style=color:#eceff4>][</span><span>i</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> *</span><span> b</span><span style=color:#eceff4>[</span><span>j</span><span style=color:#eceff4>][</span><span>i</span><span style=color:#eceff4>]</span><span style=color:#81a1c1> +</span><span style=color:#8fbcbb> D</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#eceff4>        }</span></span>
<span class=giallo-l><span style=color:#eceff4>    }</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#81a1c1>fn</span><span style=color:#88c0d0> benchmark</span><span style=color:#eceff4>(</span><span>c</span><span style=color:#81a1c1>: &mut</span><span style=color:#8fbcbb> Criterion</span><span style=color:#eceff4>) {</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> buff_size</span><span style=color:#81a1c1> =</span><span style=color:#b48ead> 0x2000</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let mut</span><span> group</span><span style=color:#81a1c1> =</span><span> c</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>benchmark_group</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>cache</span><span style=color:#eceff4>");</span></span>
<span class=giallo-l><span style=color:#81a1c1>    let</span><span> input</span><span style=color:#81a1c1> =</span><span style=color:#88c0d0> init_input</span><span style=color:#eceff4>(</span><span>buff_size</span><span style=color:#eceff4>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    group</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>bench_function</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>access_in_order</span><span style=color:#eceff4>",</span><span style=color:#81a1c1> |</span><span>b</span><span style=color:#81a1c1>|</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        b</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>iter_batched</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>||</span><span> input</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>clone</span><span style=color:#eceff4>(),</span><span style=color:#81a1c1> |mut</span><span> input</span><span style=color:#81a1c1>|</span><span style=color:#88c0d0> access_in_order</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&mut</span><span> input</span><span style=color:#eceff4>),</span><span> BatchSize</span><span style=color:#81a1c1>::</span><span style=color:#8fbcbb>SmallInput</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#eceff4>    });</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    group</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>bench_function</span><span style=color:#eceff4>("</span><span style=color:#a3be8c>access</span><span style=color:#eceff4>",</span><span style=color:#81a1c1> |</span><span>b</span><span style=color:#81a1c1>|</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>        b</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>iter_batched</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>||</span><span> input</span><span style=color:#81a1c1>.</span><span style=color:#88c0d0>clone</span><span style=color:#eceff4>(),</span><span style=color:#81a1c1> |mut</span><span> input</span><span style=color:#81a1c1>|</span><span style=color:#88c0d0> access</span><span style=color:#eceff4>(</span><span style=color:#81a1c1>&mut</span><span> input</span><span style=color:#eceff4>),</span><span> BatchSize</span><span style=color:#81a1c1>::</span><span style=color:#8fbcbb>SmallInput</span><span style=color:#eceff4>)</span></span>
<span class=giallo-l><span style=color:#eceff4>    });</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>criterion_group!</span><span style=color:#eceff4> {</span></span>
<span class=giallo-l><span>    name</span><span style=color:#81a1c1> =</span><span> bench_main</span><span style=color:#eceff4>;</span></span>
<span class=giallo-l><span>    config</span><span style=color:#81a1c1> =</span><span style=color:#8fbcbb> Criterion</span><span style=color:#81a1c1>::</span><span style=color:#88c0d0>default</span><span style=color:#eceff4>();</span></span>
<span class=giallo-l><span>    targets</span><span style=color:#81a1c1> =</span><span> benchmark</span></span>
<span class=giallo-l><span style=color:#eceff4>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#88c0d0;font-weight:700>criterion_main!</span><span style=color:#eceff4>(</span><span>bench_main</span><span style=color:#eceff4>);</span></span></code></pre><p>結果<pre class=giallo style=color:#d8dee9;background-color:#2e3440><code data-lang=plain><span class=giallo-l><span>❯ cargo criterion -- --sample-size=10</span></span>
<span class=giallo-l><span>    Finished bench [optimized] target(s) in 0.03s</span></span>
<span class=giallo-l><span>Gnuplot not found, using plotters backend</span></span>
<span class=giallo-l><span>cache/access_in_order   time:   [145.88 ms 148.53 ms 151.90 ms]                                </span></span>
<span class=giallo-l><span>Benchmarking cache/access: Warming up for 3.0000 s</span></span>
<span class=giallo-l><span>Warning: Unable to complete 10 samples in 5.0s. You may wish to increase target time to 47.4s.</span></span>
<span class=giallo-l><span>cache/access            time:   [4.2983 s 4.5101 s 4.6564 s]                          </span></span></code></pre><p>ということで、cacheを考慮した<code>access_in_order</code>のほうが速い結果が再現できました。<br> <code>pref</code>コマンドの使い方も載っており、とても参考になりました。<figure><div class=fig-images-row><img , alt src=images/cpu_no_kimochi_bench.png></div><figcaption>criterion出力結果</figcaption></figure><h2 id=di-12zhang-cputozhou-bian-ji-qi-tonojie-bituki-i-o><a aria-label="Anchor link for: di-12zhang-cputozhou-bian-ji-qi-tonojie-bituki-i-o" class=zola-anchor href=#di-12zhang-cputozhou-bian-ji-qi-tonojie-bituki-i-o>第12章 CPUと周辺機器との結びつき(I/O)</a></h2><p>CPUが周辺機器とやりとりする際にメモリマップどI/Oという仕組みでメモリ経由でデータを読み書きしているという話。<br> <a href=https://www.c-r.com/book/detail/1403 rel=external>基礎から学ぶ 組込みRust</a>をやった際に出てきた気がします。<h2 id=di-13zhang-duo-kunoshi-shi-wochai-siip-mareruli-chang-desu-ge-riip-mi><a aria-label="Anchor link for: di-13zhang-duo-kunoshi-shi-wochai-siip-mareruli-chang-desu-ge-riip-mi" class=zola-anchor href=#di-13zhang-duo-kunoshi-shi-wochai-siip-mareruli-chang-desu-ge-riip-mi>第13章 多くの仕事を差し込まれる立場です(割り込み)</a></h2><p>割り込みについての説明。<br> ベクターテーブルが割り込み次にどのように参照されるか等のっており、割り込みの説明としてとてもわかりやすかったです。<br> <a href=https://os.phil-opp.com/cpu-exceptions/ rel=external>Writing an OS in RustのCPU Exceptions</a>を読んだ際にInterrupt Descriptor Tableがよくわからなかったので最初にこの説明読んでいたらと思いました。<h2 id=fu-lu-a-ci-nidu-mubekiben><a aria-label="Anchor link for: fu-lu-a-ci-nidu-mubekiben" class=zola-anchor href=#fu-lu-a-ci-nidu-mubekiben>付録A 次に読むべき本</a></h2><p>次に読む本のオススメが挙げられています。 パタヘネ本(コンピューターの構成と設計)も載っていました。(第5版とありますが、第6版でてます)<br> パタヘネ本はオススメされて一度読んでみたのですが難しく理解できないところも多かったので理解を深めてから再挑戦したいです。<br> そしてここでも挙がるCPUの造り方。2003年の本ですが今でもオススメに上がり続けるのすごいなと思っています。<br> 自分はプロセッサを支える技術を読んでみようと思いました。</div></article></main><footer class=blog-footer><p>© 2026 <a href=https://blog.ymgyt.io> ymgyt </a> | Made with <a href=https://www.getzola.org rel=noopener target=_blank>Zola</a> | <a href=https://github.com/ymgyt/blog>Repository</a> | <a href=https://blog.ymgyt.io/atom.xml target=_blank title=rss> <svg viewbox="0 0 24 24" class=icon fill=none height=24 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=24 xmlns=http://www.w3.org/2000/svg><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx=5 cy=19 r=1></circle></svg> </a></footer></div></div>