+++
title = "📕 プログラマーのためのCPU入門を読んだ感想"
slug = "what-a-programmer-should-know-about-the-cpu"
description = "プログラマーのためのCPU入門の素晴らしさを語ります"
date = "2023-02-26"
draft = true
[taxonomies]
tags = ["book"]
[extra]
image = "images/emoji/closed_book.png"
+++

## Memo

* 2章: 命令流の密度を高めたい。(命令の完了を待たずに次の命令を実行したい)

## 読んだ本


{{ figure(images=["images/what-a-programmer-should-know-about-the-cpu-book.png"], href="https://www.lambdanote.com/products/cpu") }}

[プログラマーのためのCPU入門](https://www.lambdanote.com/products/cpu)  
著者: Takenobu Tani

会社で読まれた方がオススメされており、読んでみたので感想を書きます。  
出版社は[ラムダノート](https://www.lambdanote.com/)です。


## まとめ

非常に良かったです。この本を出版してくれてありがとうございますという感謝の気持ちでいっぱいです。  
具体的には以下の点がよかったです。

* 図
* 概念整理
* Assembly 


## 第1章 CPUは如何にしてソフトウェアを高速に実行するのか

### CPUの性能とは

本書はCPUを性能の面から眺めるのですが、そもそも性能とはというところから始めてくれます。  

$$ CPU時間 = \frac{実行命令数}{プログラム} \times \frac{クロックサイクル数}{実行命令数} \times \frac{秒数}{クロックサイクル数} $$

そして、CPUの性能とは、上記で定めるCPU時間が短いほどよいとします。

$$ CPU時間 = \frac{秒数}{プログラム} $$

のようにせず、わざわざ3項にしているかというと、各項がそれぞれ、CPUの異なる側面を表すからです。  
具体的には、第1項がプログラムを構成する命令数、コンパイラ、命令セットアーキテクチャによって決まります。  
第2項はCPUの内部構造(microarchitecture)、第3項は半導体や回路実装技術がそれぞれ対応します。

### 命令流

プログラムをbuild/compileして機械語にしてCPUに渡しますが、CPUからこの機械語がどう見えているかというと、ある種の命令流として見えていると説明されます。  
そして本書ではこの命令流を早くするためにCPUが行っている工夫と、遅くなる要因という観点から章が構成されます。


## 第2章 命令の密度を上げるさまざまな工夫

CPUの命令流を速くするためにその密度に着目します。密度というのは、実行中のCPUのスナップショットを採ったときにどれくらいの命令が実行中かという概念と理解しています。  

まず逐次処理から始めます。  


{{ figure(images=["images/pipe_1.svg"], caption="逐次処理") }}

これはある命令の実行を完了してから次の命令の実行を開始する処理方法です。実行中のCPUのどの時点でも1つの命令しか実行していないので密度としては最も低い状態です。  
さらに、命令実行の各処理(ステージ)を考慮すると逐次処理は以下のように表すことができます。

{{ figure(images=["images/pipe_2.svg"], caption="ステージaware") }}

次にパイプライン化します。今までは前の命令の実行完了まで待ってから次の命令を実行していましたが、完了まで待つのではなく、ステージの完了まで待ってから次の命令を実行します。  
この結果、ある1時点をみるとステージ数の命令が実行中となります。  

{{ figure(images=["images/pipe_3.svg"], caption="パイプライン化") }}

なお、パイプライン化により、前の命令の実行の完了を待たずに次の命令を実行することになります。これは広い意味での「投機的な処理」を導入するものと説明されます。このことが次章以降のデータ依存関係や、分岐命令の話につながります。  

そして、このパイプラインを物理的に複数設けるアプローチがスーパースカラ化です。  

{{ figure(images=["images/pipe_4.svg"], caption="スーパースカラ化") }}

最後に、ステージ分割を更に推し進め(スーパーパイプライン化)し、スーパースカラの並列度を4に、ステージ分割数を12にすると現代の標準的なCPUと同程度の規模感になるそうです。  

{{ figure(images=["images/pipe_5.svg"], caption="4並列、12段ステージ") }}

最初の逐次処理と比較すると密度が向上していることがわかります。  
スーパースカラやパイプライン化は概念としては知っていましたが命令流の密度という観点から整理してくれている本章の説明はとてもわかりやすかったです。


## 第3章 データ依存関係

第2章で導入されたパイプライン化により命令流の密度を高めることができました。ただし、パイプライン化によって、先の命令の実行完了を待たずに次の命令の実行が開始されます。  
これによって命令間に依存関係がある場合に問題が生じます。具体的には  

```
add x1, x2, x3
sub x4, x5, x1
```

のように`add`命令で更新したregisterを後続の`sub`命令で利用する場合、`add`命令の完了によってx1 registerが更新されてからでないと`sub`命令が実行できません。  
この命令を待機している間はパイプラインのステージの一部が利用されていない状態となってしまい、命令流の密度が低下してしまいます。  
そこで、依存関係によって待機している命令を実行する代わりに別の命令を先に実行することで、ステージの空きを埋めるアウトオブオーダーという手法が導入されます。  
また、データの依存関係にもいろいろ種類があり、依存関係の種類によっては、registerのリネームで対応できるといった説明もあります。  

アウトオブオーダーの存在自体は、[Atomics and Locksを読んで](https://blog.ymgyt.io/entry/rust_atomics_and_locks/)知っていたのですがどういう理由でそれが実行されるかはわかっていなかったので本章の説明はとてもわかりやすかったです。  

### 命令レイテンシの計測実験

TODO


## 第4章 分岐命令

## 第5章 キャッシュメモリ

## 第6章 仮想記憶

## 第7章 I/O

## 第8章 システムコール、例外、割り込み

## 第9章 マルチプロセッサ

## 第10章 キャッシュコヒーレンス制御

## 第11章 メモリ順序付け

## 第12章 不可分操作

## 第13章 高速なソフトウェアを書く際には何に注目すべきか

## 付録A CPUについてさらに広く深く知るには

## 付録B 各CPUの基本的な命令

## 付録C 現代的なCPUの実装例 (BOOM)

## 付録D マイクロオペレーション方式と、その命令レイテンシ

## 付録E GPUおよびベクトル方式におけるパイプラインの高密度化の工夫

## 付録F CPUの性能向上の物理的な難しさ


